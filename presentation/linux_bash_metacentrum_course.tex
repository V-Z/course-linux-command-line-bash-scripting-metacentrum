\documentclass[compress, ucs, xelatex, 11pt, xcolor=svgnames,
	hyperref={
		bookmarks=true,
		unicode=true,
		colorlinks=true,
		pdftitle={Linux, command line and MetaCentrum},
		plainpages=false,
		pdfauthor={Vojtech Zeisek},
		pdfsubject={Course about use of Linux command line, writing shell scripts and using MetaCentrum of CESNET},
		pdfcreator={XeLaTeX},
		pdfkeywords={Linux, GNU, BASH, shell, command line, MetaCentrum},
		linkcolor=DarkRed,
		anchorcolor=DarkBlue,
		citecolor=Indigo,
		filecolor=NavyBlue,
		menucolor=DarkMagenta,
		urlcolor=DarkBlue,
		pdftex},
	url={hyphens, lowtilde} % Allow line breaks within URLs
	]{beamer}

% Theme settings
\usetheme[secheader]{Boadilla}
\usecolortheme{spruce}
\setbeamertemplate{headline} {
	\begin{beamercolorbox}{section in head/foot}
		\insertsectionnavigationhorizontal{\paperwidth}{\hskip0pt plus1fill}{\hskip0pt plus1fill}
	\end{beamercolorbox}
	\begin{beamercolorbox}[ht=2ex, dp=1.125ex]{subsection in head/foot}
		\insertsubsectionnavigationhorizontal{\paperwidth}{}{\hfill\hfill}
	\end{beamercolorbox}
	}
\useinnertheme{circles}

% Basic packages
\usepackage{xltxtra} % Loads following 3 packages for processing with XeLaTeX
\usepackage{metalogo}
\usepackage{xunicode}
\usepackage{fontspec}

% Other packages
\usepackage{multicol}
\usepackage{tabularx}

% In-line higlighting
\usepackage{soul}

% Add background for \texttt{} (using pacakge soul)
\sethlcolor{Beige}
\renewcommand{\texttt}[1]{\hl{\ttfamily #1}}

% Change text color of highlighted text back to red
\renewcommand{\alert}[1]{\textcolor{red}{#1}}

% Syntax higlight
\usepackage{minted}
\usemintedstyle{vim} % Styles are listed by pygmentize -L styles; languages are listed by pygmentize -L lexers
\newminted{bash}{linenos, fontsize=\footnotesize, bgcolor=Beige, fontfamily=tt, gobble=4, numbersep=-6pt}
% Change line number style
\renewcommand{\theFancyVerbLine}{
	\sffamily
	\textcolor{BlueViolet}{
		\tiny
		\oldstylenums{
			\arabic{FancyVerbLine}
			}
		}
	}

% Fixing space before and after block of code higlight
\BeforeBeginEnvironment{bashcode}{\vspace{-1em}}
\AfterEndEnvironment{bashcode}{\par\vspace{-1em}}

% Fixing space before and after multicols region
\BeforeBeginEnvironment{multicols}{\vspace{-0.5em}}
\AfterEndEnvironment{multicols}{\par\vspace{-0.5em}}

% Fixing space before and after itemize region
\BeforeBeginEnvironment{itemize}{\vspace{-0.25em}}
\AfterEndEnvironment{itemize}{\vspace{-0.25em}}

% Default language
\usepackage[main=american, czech]{babel}

% Quotes
	\usepackage[autostyle=true, czech=quotes, english=american]{csquotes}

% Title page
\author{Vojtěch Zeisek}
\institute[\url{https://trapa.cz/}]{Department of Botany, Faculty of Science, Charles University, Prague\\Institute of Botany, Czech Academy of Sciences, Průhonice\\\url{https://trapa.cz/}, \href{mailto:zeisek@natur.cuni.cz}{zeisek@natur.cuni.cz}}
\title{Linux, command line \& MetaCentrum}
\subtitle{Use of Linux command line not only for CESNET's MetaCentrum}
\titlegraphic{\includegraphics[width=1.5cm]{tux.png}}
\date{January 29 to 31, 2019}

\begin{document}

\begin{frame}
	\titlepage
\end{frame}

\begin{frame}[allowframebreaks]{Outline}
	\tableofcontents
\end{frame}

\section{Introduction}

\begin{frame}{Introduction}{First steps in the world of Linux and open-source software}
	\tableofcontents[currentsection, sectionstyle=show/hide, hideothersubsections]
\end{frame}

\begin{frame}{The course information}
	\label{materials}
	\begin{itemize}
		\item The course page: \url{https://trapa.cz/en/course-linux-command-line-2019}
		\begin{itemize}
			\item Česky: \url{https://trapa.cz/cs/kurz-prikazove-radky-linuxu-2019}
		\end{itemize}
		\item Subject in SIS: \url{https://is.cuni.cz/studium/eng/predmety/index.php?do=predmet&kod=MB120C17}
		\begin{itemize}
			\item Česky: \url{https://is.cuni.cz/studium/predmety/index.php?do=predmet&kod=MB120C17}
			\item For students having subscribed the subject, requirements are on next slide
		\end{itemize}
		\item Working version is available at \url{https://github.com/V-Z/course-linux-command-line-bash-scripting-metacentrum} --- feel free to contribute, request new parts or report bugs
	\end{itemize}
\end{frame}

\begin{frame}{Requirements to exam (\enquote{zápočet})}
	\begin{enumerate}
		\item Be present whole course.
		\item Be active --- ask and answer questions.
		\item Write short script solving any task the student is (going to be) solving. E.g. prepare script to process student's data on MetaCentrum. Or short script to do anything the student needs to do. This will be very individual. According to topics and interests of every student. Students can of course discuss with anyone, use Internet, manuals, etc. The aim is learn how to solve real problem the student has/is going to have.
		\item Write at least one page (can be split into multiple articles) on Wikipedia about any topic discussed during the course. Again, this is very open, students can write about any topic they like. I~prefer native language of the student (typically to make larger non-English Wikipedia).
	\end{enumerate}
\end{frame}

\begin{frame}{Materials to help you\ldots}
	\begin{itemize}
		\item Download the presentation from \url{https://soubory.trapa.cz/linuxcourse/linux_bash_metacentrum_course.pdf}
		\item Download the scripts and toy data from \url{https://soubory.trapa.cz/linuxcourse/scripts_data.zip}
		\begin{itemize}
			\item \alert{Note:} Open the scripts in some \alert{good} text editor (slide~\ref{editors}) --- showing syntax highlight, line numbers, etc. (\alert{NO} Windows notepad); the files are in UTF-8 encoding and with UNIX end of lines (so that too silly programs like Windows notepad won't be able to open them correctly)
			\item \alert{Never ever} open any script file in software like MS~Word --- they destroy quotation marks and other things by \enquote{typographical enhancements} making the script unusable
		\end{itemize}
	\end{itemize}
\end{frame}

\subsection{Learning machine}

\begin{frame}{Virtual machine for learning}
	\label{VBox}
	\begin{multicols}{2}
		\begin{itemize}
			\item If you do not have Linux installed, download and install VirtualBox from \url{https://www.virtualbox.org/}
			\item Download openSUSE Leap 15.0 Linux distribution for this course from \url{ftp://botany.natur.cuni.cz/openSUSE_Leap_courses.ova} ($\sim$4~GB)
			\item Launch VirtualBox and go to menu \textbf{File | Import appliance\ldots} to import it. When done, launch it (\textbf{Start})
		\end{itemize}
		\includegraphics[height=6cm]{virtualbox.png}
	\end{multicols}
\end{frame}

\begin{frame}{Enjoy learning virtual machine for the course}
	\begin{center}
		\includegraphics[width=\textwidth-1cm]{opensuse_leap_course.png}
	\end{center}
\end{frame}

\begin{frame}{VirtualBox shared folder I}{VirtualBox can be configured to share folder with host operating system}
	\begin{center}
		\includegraphics[width=\textwidth-2cm]{virtualbox_shared_folder_1.png}
	\end{center}
\end{frame}

\begin{frame}[fragile]{VirtualBox shared folder II}{Go to menu \enquote{Devices | Shared Folders} and set pair of folders}
	\begin{bashcode}
    sudo mount -t vboxsf -o uid=$UID,gid=$(id -g) shared /mnt
	\end{bashcode}
	\vfil
	\begin{center}
		\includegraphics[width=\textwidth-1cm]{virtualbox_shared_folder_2.png}
	\end{center}
	\vfill
\end{frame}

\subsection{What it is a~\enquote{UNIX}}

\begin{frame}[allowframebreaks]{What it is UNIX, Linux and GNU}
	\begin{itemize}
		\item \href{https://en.wikipedia.org/wiki/Unix}{UNIX}
		\begin{itemize}
			\item Originally developed in Bell labs of AT\&T in 1696, written in C, since then  huge radiation, hybridization, HGT,~\ldots
			\item Trademark --- only systems passing certain conditions (paid certification) can be called \enquote{UNIX} --- Solaris, HP-UX, AIX, etc. (commercial systems for big servers)
			\item Main principles: simple, multitasking, hierarchical, network, for more users (takes cares about permissions etc.), configuration written in plain text files, important relationships among applications (generally one application = one task --- they are chained), work primarily with text, has kernel and API (interface to communicate with the rest of the system)
			\item \href{https://en.wikipedia.org/wiki/Unix-like}{UNIX-like} (UN*X, *nix)
			\begin{itemize}
				\item Systems compatible with UNIX (Linux, BSD and its variants, macOS,~\ldots)
				\item Mainly open-source (UNIX is commonly commercial --- source code is not available for public, but its specification is)
				\item Nowadays prevailing over \enquote{old} UNIX systems, used in many devices from tiny embedded toys to huge data centers
				\item Try to provide same quality as paid systems, but (mostly) for free
			\end{itemize}
			\item Many courts about copyrights, parts of code, patents --- USA allow software patents, EU not --- GNU, Linux, BSD, etc. try to ensure to have only code not covered by any patents to avoid possible courts
		\end{itemize}
		\item \href{https://www.gnu.org/}{GNU}
		\begin{itemize}
			\item \enquote{GNU's Not Unix!} --- but it is compatible, respects its principles
			\item Since 1984 Richard Stallman (founder of \href{https://www.fsf.org/}{Free Software Foundation}) tried to make new kernel (Hurd --- not finished yet\ldots)
			\item Generally set of basic system tools --- working with many kernels (Linux, BSD*, macOS,~\ldots), also present in many commercial paid UNIX systems
			\item Source code is free and open --- anyone can study it (Security!), report bugs, contribute, modify, share it,~\ldots
			\item GNU General Public License (GPL) --- free spirit of open-source --- license, idea, how to share software
		\end{itemize}
		\item \href{https://en.wikipedia.org/wiki/Linux}{Linux}
		\begin{itemize}
			\item First version of kernel written by Linus Torvalds in Helsinki in 1991
			\item Kernel was in principle inspired by various UNIX systems and using GNU tools for standard work
			\item Quickly became popular --- anyone can take it and use for any needs, adopt (modify it), etc.
			\item Used in small embedded (commonly network) devices, mobile devices (book readers, Android,~\ldots), personal computers, servers (from home level to biggest data centers),~\ldots
			\item Nowadays powering most of the Internet
			\item Anyone can contribute --- not only code, also documentation, design, translations,~\ldots
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Extremely simplified UNIX phylogeny}
	\begin{center}
		\includegraphics[height=7cm]{unix_history-simple.png}
	\end{center}
\end{frame}

\begin{frame}{Most common UNIX-based systems (except Linux)}
	\begin{itemize}
		\item \href{https://en.wikipedia.org/wiki/macOS}{macOS} (previously Mac OS~X) --- system kernel is based on older BSD and uses plenty of GNU tools (although mostly older versions)
		\item \href{https://en.wikipedia.org/wiki/Berkeley_Software_Distribution}{BSD} --- one of the oldest operating systems, still developed in \href{https://distrowatch.com/search.php?ostype=BSD}{many independent variants}
		\begin{itemize}
			\item Still very popular especially on servers, for special purposes, etc.
			\item License allows closing of the code --- used by Apple macOS kernel, PlayStation firmware,~\ldots
			\item Installation and management is for beginners usually harder than Linux, everything must be done manually, not so common as Linux anymore
			\item E.g. \href{https://www.freebsd.org/}{FreeBSD}, \href{https://www.dragonflybsd.org/}{DragonFly BSD}, \href{https://www.openbsd.org/}{OpenBSD}, \href{https://www.freenas.org/}{FreeNAS} (for storage servers),~\ldots
		\end{itemize}
		\item \href{https://en.wikipedia.org/wiki/Solaris_(operating_system)}{Solaris} --- commercial, not very common
		\begin{itemize}
			\item Mainly special servers, paid
			\item \href{https://distrowatch.com/search.php?ostype=Solaris}{Several community-based variants} freely available
		\end{itemize}
		\item Command line usage is nearly same across UN*X systems (all follow same standards)
	\end{itemize}
\end{frame}

\subsection{Licenses and money}

\begin{frame}{Cathedral vs. market place}{What is principal difference between free open-source and commercial software}
	\begin{itemize}
		\item Commercial software is like a~cathedral
		\begin{itemize}
			\item Pay big money and get it in the state which the architect like
			\item User can not modify it (or it is terribly expensive)
			\item Might be you don't need everything --- but still paying whole set
		\end{itemize}
		\item Free open-source software (FOSS) is like a~market place
		\begin{itemize}
			\item Find there many producers of same tools --- pick up those you like --- freedom of choice
			\item Take exactly the tools you need --- any combination is possible
			\item Much cheaper to shop there
		\end{itemize}
		\item Both have pros and cons --- depends what you wish\ldots
	\end{itemize}
\end{frame}

\begin{frame}[allowframebreaks]{Free and open-source software --- (F)OSS}
	\begin{itemize}
		\item \textbf{Free like freedom of speech, \alert{not} like free beer!}
		\item Not every OSS (generally less strict conditions) has to be \textbf{F}OSS (you can do with it (almost) whatever you like) --- source code might be available under some circumstance (only to look), but modification and/or reuse of the code prohibited (and then it is not \textbf{free})
		\item Open-source --- source code can be seen by the holder of the license
		\item \href{https://www.gnu.org/licenses/gpl-3.0.html}{GNU GPL} (\enquote{\href{https://www.gnu.org/copyleft/}{copyleft}}) --- probably most common OSS license, strict, viral --- derived code has to keep the license --- surprisingly not fully \enquote{free} as it doesn't allow changes of license
		\item \href{https://www.gnu.org/licenses/lgpl-3.0.en.html}{LGPL} --- Lesser GPL --- more permissive
		\item \href{https://en.wikipedia.org/wiki/BSD_licenses}{BSD license} --- permissive --- allow derived code to became closed-source (commonly used by e.g. Apple macOS, Safari browser, small electronics,~\ldots)
		\item \href{https://www.apache.org/licenses/}{Apache} or \href{https://www.mozilla.org/MPL/}{Mozilla} licenses etc. --- specific use in particular software
		\item Creative Commons (CC) --- software licenses are not suitable for multimedia, text, etc. --- CC has many options (including denial of reuse of the product), see \url{https://creativecommons.org/}
	\end{itemize}
	\begin{block}{Spirit of FOSS}
		\begin{itemize}
			\item Orientation might be tricky, but practical output for users is same --- \textbf{the software can be independently checked for bugs, backdoor, malware, can be improved and under some circumstances, new software can be derived, and usually, it is available for free}
			\item \alert{Aim is to \enquote{liberate} software to keep open sharing of ideas, mutual improve and security control} --- although the point is clear, there are debates how to reach it\ldots
		\end{itemize}
	\end{block}
	\begin{itemize}
		\item And \href{https://en.wikipedia.org/wiki/Comparison_of_free_and_open-source_software_licenses}{many} \href{https://opensource.org/licenses}{more} licenses\ldots
	\end{itemize}
\end{frame}

\begin{frame}{How to make money with free open-source software?}
	\begin{itemize}
		\item Traditional model --- user rents right (\enquote{buys a~license}) to use the software (and sometimes for support --- usually for extra money)
		\item Common mistake --- software is not \enquote{bought} --- only license is rented (\enquote{permission to use it})
		\item Software as service
		\begin{itemize}
			\item (F)OSS is available for free --- user can use it as it is or buy a~support --- help of any type
			\item No vendor lock-in --- user has the code, so he can modify the software himself, change provider of the services,~\ldots
			\item Cheap for user as well as company --- company specialized for one task, let's say server database, doesn't have to take care about the rest of the system --- someone else does; user pays only what he needs
			\item Our faculty is using \href{https://plone.org/}{Plone} system for web pages --- anyone can use it for free, someone (like we) asked a~company to help, and if we'd decided, we  could keep Plone and maintain it ourselves or find another company to help us with it
		\end{itemize}
	\end{itemize}
\end{frame}

\section{Linux}

\begin{frame}{Linux}{Generally about Linux}
	\tableofcontents[currentsection, sectionstyle=show/hide, hideothersubsections]
\end{frame}

\begin{frame}{What it is a~\enquote{Linux}}
	\begin{itemize}
		\item Operating system respecting principles of UNIX
		\item Components
		\begin{itemize}
			\item Linux \textbf{kernel} --- basic part of the system responsible for hardware and very basic low-level running of the system (\enquote{\textbf{Linux \textit{sensu stricto}}})
			\item GNU core utilities --- basic applications
			\item Graphical user environment (GUI) --- many choices
			\item Many other applications --- according to use --- whatever imaginable
		\end{itemize}
		\item Linux \textbf{distribution (\enquote{Linux \textit{sensu lato}})}
		\begin{itemize}
			\item Somehow assemble Linux kernel, basic tools and some applications
			\item Optionally add some patches and extra tools and gadgets
			\item Make your own design! (very important;)
			\item If lazy, remake existing distribution (using e.g. \href{http://openbuildservice.org/}{web service})
			\item Still surprised there are hundreds of them?
			\item It is like Lego --- pieces are more or less same across distributions, but result is very variable
			\item From \enquote{general} for daily use (pick up whatever you like) to very specialized --- special hardware devices, network services, rescue,~\ldots
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Linux kernel and other parts around it}
	\includegraphics[width=\textwidth]{linux_kernel_ubiquity.png}
	\vfil
	\url{https://en.wikipedia.org/wiki/Linux_distribution}
	\vfill
\end{frame}

\begin{frame}{Extremely simplified adaptive radiation of Linux distributions}
	\includegraphics[width=\textwidth]{linux_fylogen_2.png}
	\vfil
	\url{https://en.wikipedia.org/wiki/List_of_Linux_distributions} and \url{https://distrowatch.com/} ($\sim$850 distributions, $\sim$280 active)
	\vfill
\end{frame}

\subsection{Choose one}

\begin{frame}{Most common Linux distributions}
	\begin{itemize}
		\item \href{https://distrowatch.com/search.php?package=DEB}{Debian (DEB) based}
		\begin{itemize}
			\item \href{https://www.debian.org/}{Debian} --- one of oldest and most common, especially on servers
			\item \href{https://www.ubuntu.com/}{Ubuntu} (nowadays probably the most popular on PCs and notebooks) and derivatives --- \href{https://www.kubuntu.org/}{Kubuntu}, \href{https://xubuntu.org/}{Xubuntu}, \href{https://lubuntu.net/}{Lubuntu},~\ldots~(according to GUI used --- most of the system is same)
			\item \href{https://linuxmint.com/}{Mint} --- Based on Ubuntu as well as Debian, very user-friendly
			\item \href{https://www.kali.org/}{Kali}, \href{https://knopper.net/knoppix/index-en.html}{KNOPPIX}, \href{https://elementary.io/}{elementaryOS},~\ldots
		\end{itemize}
		\item \href{https://distrowatch.com/search.php?package=RPM}{Red Hat (RPM) based}
		\begin{itemize}
			\item \href{https://www.redhat.com/}{Red Hat} --- probably the most common commercial
			\item \href{https://getfedora.org/}{Fedora} --- \enquote{playground} for Red Hat --- very experimental
			\item \href{https://www.centos.org/}{Centos} --- Clone of Red Hat
			\item \href{https://www.opensuse.org/}{openSUSE} --- SUSE is second largest Linux company, openSUSE is community distribution (free) companion of SUSE Linux Enterprise
			\item \href{https://www.scientificlinux.org/}{Scientific Linux}, \href{https://www.mageia.org/}{Mageia}, \href{https://www.pclinuxos.com/}{PCLinuxOS},~\ldots
		\end{itemize}
		\item Android
		\item For experienced users: Arch, Slackware, Gentoo,~\ldots
	\end{itemize}
\end{frame}

\begin{frame}{Graphical User Interfaces (GUI)}{More like \enquote{Mac-style}, \enquote{Windows-style} or something else? Feature rich or minimalistic?}
	\begin{itemize}
		\item Most of GUIs are available for most of common distributions --- one is picked as default and \enquote{only} color style is different
		\item \href{https://code.launchpad.net/unity}{Unity} --- originally developed by Ubuntu (discontinued, now community based), \enquote{Mac-style}
		\item \href{https://www.kde.org/}{KDE} --- one of the most common, feature extremely rich, basically \enquote{Windows-like} (can be changed)
		\item \href{https://www.gnome.org/}{GNOME} --- one of the most common, relatively simplistic interface, but still feature rich, \enquote{Mac-like}
		\item \href{https://xfce.org/}{XFCE} --- lightweight version of older GNOME --- for older computers or users not willing to be disturbed by graphical effects, basically \enquote{Mac-like} looking, but panels can be moved to \enquote{Windows style}
		\item \href{https://developer.linuxmint.com/projects/cinnamon-projects.html}{Cinnamon} --- remake of GNOME to look more like Windows\ldots
		\item And much more\ldots
		\item Choose what you like --- doesn't matter much which one\ldots
	\end{itemize}
\end{frame}

\begin{frame}{Ubuntu with GNOME} % TODO Update print screen, add more
	\begin{center}
		\includegraphics[width=\textwidth]{ubuntu.png}
	\end{center}
\end{frame}

\begin{frame}{openSUSE with KDE --- Kubuntu is same, but blue\ldots} % TODO Update print screen, add more
	\begin{center}
		\includegraphics[height=7cm]{opensuse.png}
	\end{center}
\end{frame}

\begin{frame}{Fedora with GNOME --- GNOME is always almost same} % TODO Update print screen, add more
	\begin{center}
		\includegraphics[height=7cm]{fedora.png}
	\end{center}
\end{frame}

\begin{frame}{Linux Mint with Cinnamon} % TODO Update print screen, add more
	\begin{center}
		\includegraphics[height=7cm]{mint.png}
	\end{center}
\end{frame}

\begin{frame}{Debian with XFCE --- Xubuntu has more \enquote{modern} design} % TODO Update print screen, add more
	\begin{center}
		\includegraphics[height=7cm]{debian.png}
	\end{center}
\end{frame}

\begin{frame}{XFCE in Xubuntu, openSUSE, Fedora and Linux Mint} % TODO Update print screen
	\begin{center}
		\includegraphics[width=\textwidth]{xfce.png}
	\end{center}
\end{frame}

\begin{frame}{Dolphin (KDE file manager) --- default for openSUSE (inset) and after tuning in the same distribution\ldots} % TODO Update print screen
	\begin{center}
		\includegraphics[width=\textwidth-0.5cm]{dolphin.png}
	\end{center}
\end{frame}

% TODO More about GUI usage:
% * Editing DE settings
% * Managing global settings and applications
% * What is stored where

\begin{frame}[allowframebreaks]{How to try Linux?}
	\begin{itemize}
		\item Install it on some computer together with or instead of Windows
		\begin{itemize}
			\item If you can use whole disk, just boot from CD/USB and click \enquote{Next}\ldots
			\item If you don't have whole disk, you need at least one (commonly more) disk partition(s) --- if you don't know how to manage them, ask someone skilled\ldots
		\end{itemize}
		\item Live CD/USB
		\begin{itemize}
			\item The most easy --- burn ISO image of CD from web of almost any Linux distribution or use for example \href{https://unetbootin.github.io/}{UNetbootin} to prepare bootable flash
			\item You only have to know how to boot from CD/USB (usually press \texttt{ESC}, \texttt{DEL}, \texttt{F2}, \texttt{F10}, \texttt{F12},~\ldots{ }when starting computer --- varies according to manufacturer)
		\end{itemize}
		\item Virtualization (slide~\ref{VBox})
		\begin{itemize}
			\item Requires relatively powerful computer (preferable Intel i5 or i7 or AMD Ryzen and over 4--8~GB of RAM)
			\item Install virtual machine (probably the most easy is \href{https://www.virtualbox.org/}{VirtualBox}) --- allows install and run another operating system inside host as an ordinary application --- very easy and comfortable
		\end{itemize}
		\item Linux subsystem in MS Windows 10 Store
		\begin{itemize}
			\item To install follow \url{https://docs.microsoft.com/windows/wsl/about}
			\item Only for command-line applications, does not aim to GUI
		\end{itemize}
		\item Cygwin
		\begin{itemize}
			\item Download and install from \url{https://www.cygwin.com/}
			\item It is not native Linux, it is collection of GNU and open-source utilities compiled to work on Windows
			\item Follows POSIX standards (i.e. it works like normal UNIX command line, with all features)
			\item Every application must be specially compiled to be able to work under Cygwin (it is sometimes complicated)
			\item Collection is large, include also GUI and DE, but not everything is easy working
		\end{itemize}
	\end{itemize}
\end{frame}

\subsection{Differences}

\begin{frame}{The Linux diversity\ldots}
	\begin{itemize}
		\item Try several distributions and just choose one you like\ldots
		\item If selecting among the most common, it doesn't matter much which one you pick up
		\item Which design do you like?
		\item Which distribution is your friend or colleague using? To have someone to ask for help\ldots
		\item You can change GUI (or its design) without change of distribution, it use to be highly configurable
		\item Applications are still same --- no difference in Firefox across distributions --- keep your settings when changing distribution
		\item Everyone using Android is using Linux
		\item Special use --- \href{https://www.freenas.org/}{FreeNAS} for home as well as business file servers, \href{https://partedmagic.com/}{Parted Magic} and/or \href{https://www.system-rescue-cd.org/}{SystemRescueCD} to repair broken system (disk failure) and save data,~\ldots
	\end{itemize}
\end{frame}

\begin{frame}{Differences among (common) Linux distributions}
	\begin{itemize}
		\item Design and colors ;-)
		\item Default GUI (others can be installed)
		\item Applications available right after installation
		\item Default settings (not much)
		\item Package management --- especially in command line
		\item Development model --- conservative or experimental, fast or slow
		\item Management of system services (how to start/stop certain services like database or web server) --- not important for daily usage for most of users
		\item Sometimes in location of some system files --- also not important in daily usage of most of users
		\item Kernel is almost same, applications are same and used in same way
		\item Command line is almost same across Linux, and almost same as in other UNIX systems (macOS,~\ldots)
	\end{itemize}
\end{frame}

\section{UN*X}

\begin{frame}{UN*X}{Theory and principles of UNIX-based operating systems}
	\tableofcontents[currentsection, sectionstyle=show/hide, hideothersubsections]
\end{frame}

\subsection{Disks and file systems}

\begin{frame}{Short overview of hard disk layout}
	\begin{itemize}
		\item Physical disk (piece of hardware) has at least 1~partition --- division seen in Windows as \enquote{disks} (\texttt{C}, \texttt{D},~\ldots) and mounted directory in UNIX
		\item MBR --- older description of disk division, up to 4~primary partitions (OS typically requires at leas one to run), one can be extended and contain more partitions, disks up to 2~TB
		\item GPT --- newer, no relevant limits, requires UEFI (replacement of BIOS --- responsible for computer to start in newer computers)
		\item If unsure what to do, high probability to break it\ldots
		\item Blank new partition has to be formatted to desired file system according to use and target operating system
		\item Linux distributions have easy graphical tools to manage disk partitions (e.g. \href{https://gparted.org/}{GParted})
		\item Always have backup before such management!
	\end{itemize}
\end{frame}

\begin{frame}{Comparison of file systems (limits and compatibility)}
	\label{fs}
	\begin{center}
		\begin{footnotesize}
			\begin{tabular}{ccccccc}
				\begin{tabular}[x]{@{}c@{}}\textbf{FS}\\\textbf{name}\end{tabular} & \begin{tabular}[x]{@{}c@{}}\textbf{Name}\\\textbf{length}\end{tabular} & \begin{tabular}[x]{@{}c@{}}\textbf{Signs}\\\textbf{in name}\end{tabular} & \begin{tabular}[x]{@{}c@{}}\textbf{Path}\\\textbf{length}\end{tabular} & \begin{tabular}[x]{@{}c@{}}\textbf{File}\\\textbf{size}\end{tabular} & \begin{tabular}[x]{@{}c@{}}\textbf{Partition}\\\textbf{size}\end{tabular} & \begin{tabular}[x]{@{}c@{}}\textbf{Supported}\\\textbf{systems}\end{tabular}\\
				FAT32 & 255 & Unicode & No limit & 4 GiB & 2 TiB & Any\\
				exFAT & 255 & ? & No limit & 16 EiB & 64 ZiB & Any\\
				NTFS & 255 & Variable & Variable & 16 TiB & 16 EiB & \begin{tabular}[x]{@{}c@{}}Windows\\(UN*X)\end{tabular}\\
				HFS+ & 255 & Unicode & Unlimited & 8 EiB & 8 EiB & macOS\\
				ext4 & 255 & Any, not / & No limit & 16 TiB & 1 EiB & Linux (UN*X)\\
				XFS & 255 & Any & No limit & 9 EiB & 9 EiB & Linux (UN*X)\\
				Btrfs & 255 & Any & No limit & 16 EiB & 16 EiB & Linux (only?)\\
				ZFS & 255 & Unicode & No limit & 16 EiB & 256 ZiB & UN*X
			\end{tabular}
		\end{footnotesize}
	\end{center}
	\begin{itemize}
		\item FAT32 (including extensions) is old-fashioned and not reliable FS
		\item NTFS and FAT do not support UNIX permissions, so they can't be used as system partition in Linux; see \href{https://en.wikipedia.org/wiki/Comparison_of_file_systems}{full comparison}
		\item Btrfs, ext4, XFS and ZFS are not accessible from Windows at all
		\item Btrfs, XFS and ZFS are the most advanced FS in common use
	\end{itemize}
\end{frame}

\begin{frame}[allowframebreaks]{Creation and control of FS}
	\begin{itemize}
		\item All commands require root privileges (slide~\ref{root})
		\item -\texttt{fdisk l} lists disks and partitions
		\item To manage disk partitioning use \texttt{fdisk /dev/sdX} or \texttt{gdisk /dev/sdX}
		\item When hard drive is partitioned, partitions must be formatted in next step
		\item Commands \texttt{mkfs.*} create various FS, common syntax is \texttt{mkfs.XXX} -\texttt{parameters /dev/sdXY}, where sdXY is particular disk partition
		\item Parameters can set label and various settings of behavior of the disk partition, check \texttt{man mkfs.XXX}
		\item To check FS for errors use \texttt{fsck.XXX /dev/sdXY} (according to respective FS)
		\begin{itemize}
			\item The filesystem must be unmounted when checking it
			\item XFS uses \texttt{xfs\_repair /dev/sdXY}
			\item Btrfs uses \texttt{btrfs check /dev/sdXY}, if it is unmountable, \texttt{btrfs}-\texttt{zero}-\texttt{log /dev/XY} use to help, last instance is \texttt{btrfs check} -{-}\texttt{repair /dev/sdXY} (dangerous operation)
			\item If Btrfs is mountable, but there are various FS errors and/or performance issues, \texttt{btrfs scrub start} -\texttt{Bdf /mount/point}, \texttt{btrfs filesystem defragment} -\texttt{r} -\texttt{v /mount/point} and \texttt{btrfs balance start} -\texttt{v /mount/point} --- manual running can take long time and strongly slow down the computer
		\end{itemize}
		\item \texttt{tune2fs} -\texttt{parameters /dev/sdXY} can set various parameters to influence behavior of disk (labels and more) partition
		\item \texttt{hdparm} -\texttt{parameters /dev/sdX} can set advanced hardware parameters of hard drive
		\item The most convenient is using graphical tools available in all distributions\ldots
		\begin{itemize}
			\item In \href{https://en.opensuse.org/Portal:YaST}{openSUSE there is YaST} administrative module --- from command line launch \texttt{yast} -{-}\texttt{qt partitioner} for graphical or \texttt{yast disk} for text-based version
			\item All distributions have graphical tools like \href{https://gparted.org/}{GParted} where it is possible to comfortable manage disks
		\end{itemize}
		\item \texttt{df} -\texttt{h} shows available/occupied space on disks/partitions, but because of special features of Btrfs it doesn't show every time correct values for this FS --- it is better to use \texttt{btrfs filesystem df /mount/point} (\texttt{/mount/point} use to be the most commonly \texttt{/})
		\item On UNIX FS, defragmentation and another maintenance tasks use to be done in background when computer is idling --- unless there is at least $\sim$20\% of free space on the device, this is not any problem and there are no performance issues
		\item \alert{Users must be sure what is doing, otherwise system can be damaged}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Another manipulations and information}
	\begin{itemize}
		\item \texttt{dd} is powerful, but potentially dangerous tool used to backup or write disks or partitions (commonly to create bootable USB media)
		\item If writing disk image to the disk (\texttt{sdX}), disk's partition table is discarded and the disk is covered by whatever is in the ISO image
	\end{itemize}
	\begin{bashcode}
    dmesg # Recent entries in main system log - filter with grep, tail, ...
    dmesg | grep sd | tail # Get information about recently plugged media
    # dd produces physical copy of whole device - including empty space
    dd if=/dev/sdXY of=image.iso # Backups disk sdXY to imago.iso
    dd if=image.iso of=/dev/sdX # Used to write e.g. image of Linux live
                                # media to USB flash disk (Check sdXY!)
    lnav # Comfortably browse recent logs, quit by "q"
	\end{bashcode}
	\begin{itemize}
		\item If there are encrypted partitions, they are in \texttt{/dev/mapper/\ldots}
		\item If LVM (slide~\ref{LVMRAID}) is used, see \texttt{lvscan} and \texttt{pvscan} to find correct location in \texttt{/dev/}
		\item Disks are also accessible through \texttt{/dev/disk/by}-\texttt{<TAB><TAB>}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Mounting and unmounting disks and removable media}
	\begin{itemize}
		\item Mounting and unmounting of devices require root privileges
		\item In Linux, physical disks are named from \texttt{sda} to \texttt{sdz}, each disk has partitions (at least one) numbered from \texttt{1}, e.g. \texttt{sda1}, \texttt{sda2}, \texttt{sdb1},~\ldots{ }--- all are accessible in \texttt{/dev} directory (\texttt{/dev/sdc3},~\ldots)
		\item Target mount point must exist before mounting
	\end{itemize}
	\begin{bashcode}
    eject # Open CD/DVD drive
    mount # Which FS (disk partitions) are mounted
    findmnt # See mounted devices in tree-like structure
    mkdir /mnt/point # Directory must exist prior mounting into it
    # mount usually recognize FS of mounted device, if not, us -t FS_type
    mount /dev/sdXY /mount/directory # Mount disk sdXY to /mount/directory
    umount /dev/sdXY # Unmount disk sdXY
    umount /mount/directory # Unmount disk from /mount/directory
    # Mount CD/DVD ISO image file into directory /mnt/iso
    mount -t iso9660 -o loop file.iso /mnt/iso # See CD/DVD image content
	\end{bashcode}
\end{frame}

\begin{frame}{Put together more disks}{Extend space and get higher data security}
	\label{LVMRAID}
	\begin{itemize}
		\item \href{https://en.wikipedia.org/wiki/RAID}{RAID} --- Redundant Array of Inexpensive/Independent Disks
		\item RAID~0~--- stripping, no redundancy, no security, speed up (two or more disks joined into one, files divided among disks)
		\item RAID~1~--- mirroring --- even number of disks of same size --- resulting capacity is half, very fast, secure
		\item RAID~5~--- at least three disks, one is used for parity control, little bit slower, popular in cheaper storage servers (NAS)
		\item Combinations (RAID~10,~\ldots)
		\item \href{https://en.wikipedia.org/wiki/Logical_volume_management}{LVM} --- Logical Volume Management --- built over several partitions/disks --- seen by OS as one continuous space, can be dynamically managed
		\item Functionality of RAID and LVM (and more) is more or less covered by Btrfs, XFS and ZFS
	\end{itemize}
\end{frame}

\subsection{Types of users}

\begin{frame}{Root vs. \enquote{normal} user}
	\label{root}
	\begin{itemize}
		\item Root is administrator --- more than God --- can do anything
		\item Other users have limited permissions
		\begin{itemize}
			\item System users providing particular service (web server, database, networking service) are as restricted as possible to do the task --- security
			\item \enquote{Human} users don't have access to system files (at least not for modification), homes of users are separated
		\end{itemize}
	\end{itemize}
	\begin{center}
		\includegraphics[height=3.25cm]{sandwich.png}
	\end{center}
	\begin{flushright}
		\url{https://xkcd.com/149/}
	\end{flushright}
\end{frame}

\begin{frame}[fragile]{Becoming root}
	\begin{itemize}
		\item Root privileges are required for any administrative task (install of software package, change of system settings,~\ldots)
		\item Word \enquote{root} is used as name for system administrator user and also for top of filesystem directory hierarchy (\texttt{/})
	\end{itemize}
	\begin{bashcode}
    # Gain root privileges
    su # Requires root password (stay in current directory)
    su - # Requires root password (go to /root)
    su -c "some command" # Launch one command with root permissions
    su USER # Became USER (his password is required)
    sudo -i # For trusted users, became root (asks for user's password)
            # User has to be listed in /etc/sudoers
    sudo somecommand # Launch somecommand with root's privileges
                     # Can be restricted for particular commands
    cat /etc/passwd # See all users (including system users)
	\end{bashcode}
\end{frame}

\subsection{Files and directories}

\begin{frame}{Everything is (text) file}
	\begin{itemize}
		\item In UNIX specifications, everything is (text) file
		\begin{itemize}
			\item Technically, directory is \enquote{just} a~file listing its content
			\item Text files are easy to read, parse, manipulate
			\begin{itemize}
				\item Very easily editable (easy to change configuration)
				\item Easy to transfer to another system
				\item Easily comparable among users/versions/systems
			\end{itemize}
			\item UNIX command line tools are the most powerful when processing text files (of any sort, e.g. genetic data)
		\end{itemize}
		\item When transferring to and from Windows, be aware of EOL and encoding (slide~\ref{eolenc})!
		\item FAT32 (commonly used for USB flash disks) has limits to maximal file size($\sim4$~GB) and range of characters allowed in file name is limited (slide~\ref{fs}), it doesn't support UNIX permissions (breaks executability of scripts)
		\begin{itemize}
			\item Avoid large single files and in file names keep only alphanumerical characters, dots and underscores (omit spaces and accented characters)
		\end{itemize}
		\end{itemize}
\end{frame}

\begin{frame}[fragile]{File names}
	\label{filenames}
	\begin{itemize}
		\item Linux allows \alert{any} character in file name, except \alert{slash} (\texttt{/}), so including anything on keyboard as well as line break (\alert{!}) --- be conservative\ldots
	\end{itemize}
	\begin{bashcode}
    mkdir My New Directory # Produces THREE directories (mkdir creates
                           # directories; spaces separate parameters)
                           # Solutions:
    mkdir "My New Directory" # (you can use single quotes '...' as well) or
    mkdir My\ New\ Directory # "\" escapes following character
    rmdir My\ New\ Directory # Same problem and solution when removing it
    touch \* # Creates new empty file named just * (yes, asterisk)
    rm * # What would be removed? :-)
    rm \* # This works...
	\end{bashcode}
	\begin{itemize}
		\item Files and directories starting by \alert{dot} (\texttt{.}) are hidden by default (typically user settings and application data in user home)
	\end{itemize}
	\begin{bashcode}
    touch .hiddenfile # Let's make empty text file hidden by default
    ls # We will not see it (ls lists only "visible" files/directories)
    ls -a # We will see it ("-a" to see all - also hidden - files/dirs)
	\end{bashcode}
	\alert{Task:} Try everything on this slide, also with different file names and characters!
\end{frame}

\begin{frame}[allowframebreaks]{Directory structure in Linux}
	\begin{itemize}
		\item It is similar also in another UN*X systems
		\item Top directory \enquote{\texttt{/}} --- \enquote{root}
		\item Everything else (including disks and network shares) are mounted in subdirectories (\texttt{/...})
		\item \texttt{/bin} --- very basic command line utilities
		\item \texttt{/boot} --- bootloader responsible for start of system
		\item \texttt{/dev} --- devices --- representations of disks, CD, RAM, USB devices,~\ldots
		\item \alert{\texttt{/etc}} --- system configuration in plain text files --- edit them to change system-wide settings (read documentation and comments there)
		\item \alert{\texttt{/home}} --- users' homes
		\item \texttt{/lib}, \texttt{/lib64} --- basic system libraries (32 and 64bits)
		\item \texttt{/lost+found} --- feature of FS, after crash and recovery of FS, restored files are there
		\item \alert{\texttt{/media}} --- attached disks (USB flash,~\ldots) usually appear there (might be in \texttt{/var/run/media}) --- subdirectories are automatically created when device is plugged and disappears when unplugged
		\item \texttt{/mnt} --- usually manually mounted file systems (but they can be mounted elsewhere according to needs)
		\item \texttt{/opt} --- optional, usually locally compiled software
		\item \texttt{/proc} --- dynamic information about system processes
		\item \texttt{/root} --- root's (admin's) home
		\item \texttt{/run} --- temporal ID files (locks) of running processes
		\item \texttt{/sbin} --- basic system utilities
		\item \texttt{/selinux} --- SELinux is security framework
		\item \texttt{/srv} --- FTP and WWW server data (can be in \texttt{/var/srv})
		\item \texttt{/sys} --- basic system
		\item \texttt{/tmp} --- temporary files --- users have private dynamically created spaces there, used automatically by applications according to need
		\item \texttt{/usr} --- binaries (executable applications) and libraries of installed applications
		\item \alert{\texttt{/var}} --- data of most of applications and services, including e.g. database data, system logs,~\ldots
		\item \alert{\texttt{/windows}} --- if on dual boot, Windows disks are commonly mounted here
		\item Can be altered, modified
		\item E.g. MetaCentrum has storage servers in various locations accessible from front and calculation nodes in \texttt{/storage}
		\item Usually, work only in your home, anywhere else modify files only if you are absolutely sure what you are doing
		\item Normal user doesn't have permission to modify files outside his directory (with exception of plugged removable media, etc.)
		\item Try \texttt{man hier} for details
	\end{itemize}
\end{frame}

\begin{frame}{Configuration in /etc (examples)}
	\begin{itemize}
		\item Configuration of system services (servers,~\ldots) and behavior
		\begin{itemize}
			\item Apache web server, database, FTP server, networking, basic system settings,~\ldots
		\end{itemize}
		\item \texttt{cron*} --- cron automatically repeatedly runs tasks
		\item \texttt{fstab} --- description of FS mounted during startup
		\item \texttt{group} --- list of users and groups
		\item \texttt{passwd} --- basic settings for new users (home directory, default shell,~\ldots)
		\item \texttt{resolv.conf} ---  DNS settings (part of basic networking)
		\item \texttt{shadow} --- users passwords in encrypted form
		\item \texttt{skel} --- basic directories and configuration for new users
		\item Much more according to software installed\ldots
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Example of configuration in /etc/ssh/sshd\_config}
	\begin{bashcode}
    # This is the ssh client system-wide configuration file.  See
    # ssh_config(5) for more information.  This file provides defaults for
    # users, and the values can be changed in per-user configuration files
    # or on the command line.
    # Minimum accepted size of the DH parameter p. By default this is set to
    # 1024 to maintain compatibility with RFC4419, but should be set higher.
    # Upstream default is identical to setting this to 2048.
    #KexDHMin 1024
    Host *
    # If you do not trust your remote host (or its administrator), you
    # should not forward X11 connections to your local X11-display for
    # security reasons: Someone stealing the authentification data on the
    # remote side (the "spoofed" X-server by the remote sshd) can read your
    # keystrokes as you type, just like any other X11 client could do.
    # Set this to "no" here for global effect or in your own ~/.ssh/config
    # file if you want to have the remote X11 authentification data to
    # expire after twenty minutes after remote login.
    ForwardX11Trusted yes
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{Types of files}
	\begin{bashcode}
    ls -la ~
	\end{bashcode}
	\begin{itemize}
		\item Regular file --- ordinary file, marked by dash (--)
		\item Directory --- in UNIX special type of file, marked by \texttt{d}
		\item Symbolic link (symlink, \enquote{soft link}) --- points to another place, marked by \texttt{l}, slide \ref{links}
		\item Hard link --- just another name for existing file, no special symbol, slide \ref{links}
		\item Block and character device --- in \texttt{/dev}, representations of devices (hard disks, terminals,~\ldots), marked by \texttt{b} or \texttt{c} respectively
		\item Named pipe --- pipe can be saved (by \texttt{mkfifo}), looks like a~file, more at slide \ref{pipe}
		\item Socket --- for communication among processes, also bidirectional, available on network
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Links}
	\label{links}
	\begin{itemize}
		\item Soft links --- like links on the web --- short-cut to another place
		\begin{itemize}
			\item When we delete link, nothing happens, when target, non-working link remains
		\end{itemize}
	\end{itemize}
	\begin{bashcode}
    ln -s source target # Source will point to target
    ls -l bin/cinema5
    lrwxrwxrwx 1 vojta users 42 5. dub 2014 cinema5 -> # "l" marks link
      /home/vojta/bin/cinema5-0.2.1-beta/cinema5* # "->" points to target
	\end{bashcode}
	\begin{itemize}
		\item Hard links --- only second name for file already presented on the disk (available only for files): \texttt{ln source target}
		\begin{itemize}
			\item If any one of the two files is deleted, the second remains to be fully working
		\end{itemize}
	\end{itemize}
	\begin{bashcode}
    ln .bashrc .bashrcX
    ls -l .bash* # Numbers in first column show links pointing to it
                 # For directories - number of items, for files = 1
    -rw------- 1 vojta users 7298 21. jan 16.43 .bash_history # One link
    -rw-r--r-- 2 vojta users 2707 29. nov 16.21 .bashrc # Same file as below
    -rw-r--r-- 2 vojta users 2707 29. nov 16.21 .bashrcX # Two links
	\end{bashcode}
\end{frame}

\subsection{Permissions}

\begin{frame}{Owner and group}
	\begin{itemize}
		\item Every file has an owner and group --- for finer setting of rights
		\item Group can have just one member --- the user
		\item System usually shows names of groups and users, but important are IDs (numbers): GID and UID
		\item Commands \texttt{chown} to change owner requires root privileges
		\item Commands \texttt{chgrp} to change group commonly requires root privileges --- user has to be member of particular group to be able to change ownership to it (if not, \texttt{root} must do it)
		\item Information about users and groups and their IDs are in \texttt{/etc/group} and \texttt{/etc/passwd}
		\item Ownership (and permissions, slide~\ref{permissions}) are important especially on servers with plenty of users
		\item It is not possible to add particular permissions for particular user on one file --- there must be special group or ACL must be used (slide~\ref{acl})
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Change owner and/or group}
	\begin{bashcode}
    ls -l # Shows also owner and group (columns 3 and 4):
    drwxr-xr-x 1 vojta users    80  5. jan 16.12 linuxcourse
    drwxr-xr-x 1 vojta users  1648 31. jan 10.15 presentation
    -rw-r--r-- 1 vojta users  1944  5. jan 15.18 README
    drwxr-xr-x 1 vojta users   822 29. jan 10.12 scripts_data
    -rwxr-xr-x 1 vojta users  1126  5. jan 15.22 web_update.sh
    l # Common alias for 'ls -l' or 'ls-la' (according to distribution)
    ll # Common alias for 'ls -l' or 'ls-la' (according to distribution)
    id # Display UID and GIDs of current user
    # New owner or group can be defined as name or ID
    chown newowner:newgroup files # Change owner and group
    chown -R newowner files # Recursively (-R) change owner
    chgrp -R newgroup files # Recursively (-R) change group
    chown --help # Or 'man chown' for more options
    chgrp --help # Or 'man chgrp' for more options
	\end{bashcode}
	\begin{itemize}
		\item Equally important is to have correct permissions (especially on server) --- next slides
	\end{itemize}
\end{frame}

\begin{frame}{File and directory permissions}
	\label{permissions}
	\begin{itemize}
		\item Combination of permissions to read/write/execute for user(owner)/group members/others
	\end{itemize}
	\begin{center}
		\begin{tabular}{llll}
			\textbf{Permission} & \textbf{Number} & \textbf{Directory} & \textbf{File}\\
			r & 4 & Read content & Read content\\
			w & 2 & Write into it & Write into it\\
			x & 1 & Enter it & Launch application
		\end{tabular}
	\end{center}
	\begin{itemize}
		\item \texttt{rwxrw}-\texttt{r}-{-} --- 3*3 characters for permissions for owner of the file/directory, group it is belonging to, and other users (\texttt{d} on beginning marks directories, \texttt{l} links, \texttt{+} ACL, slide \ref{acl})
		\item \texttt{764} --- same as above --- numbers for each role are summed --- first one is for owner, second for group and last for others
		\item Executable scripts and binaries \textbf{require} executable permission (\texttt{x})
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Permissions examples}
	\begin{bashcode}
    ls -l # Shows permissions, links, owner, group, size, date, name
    # Only owner can read and write the file; 600:
    -rw-------   1 vojta users   38211 20. jan 09.23 .bash_history
    # Owner can write read and write the file, others read; 644:
    -rw-r--r--   1 vojta users    2707 29. nov 16.21 .bashrc
    # Owner can enter, read and write directory, others can read
    # and enter it; 755:
    drwxr-xr-x  41 vojta users    4096 27. pro 09.55 bin
    # Only owner can read, write and enter the directory,
    # others nothing; 700:
    drwx------  58 vojta users    4096 17. pro 15.45 .config
    # Link, everyone can do everything; 777:
    lrwxrwxrwx   1 vojta users      37 20. jan 09.33 .lyxpipe.in ->
      /tmp/kde-vojta/kilemj7d3E/.lyxpipe.in
    # Executable (application) - everyone can launch it, but only
    # owner can write into the file; 755:
    -rwxr-xr-x   1 vojta users    2187 27. nov 13.10 strap.sh*
	\end{bashcode}
	\vfil
	\begin{itemize}
		\item Permission to \enquote{write} also means permission to \textbf{delete} it
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Check and modify permissions}
	\begin{bashcode}
    ls -l # Long list - file names and attributes
    ls -a # All, including hidden files (starting with dot)
    ls -F # Add on the end of name / for directories and * for executable
    ls -h # Human readable size units (use with -l or -s)
    ls --color ## Colored output
    ls -laFh --color # Combine any parameters you like
    chmod u/g/o/a+/-r/w/x FILE # For respective user/group/others/all adds
                               # /removes permission to read/write/execute
    chmod XYZ FILE # Instead of XYZ use number code of permission
    chmod -R # Recursive (including subdirectories)
    chmod +x script.sh # Make script.sh executable for everyone
    chmod o-r mydir # Remove read permission from others on mydir
    chmod 600 FILE1 FILE2 # Make both files readable and
                          # writable only by their owner
    chmod 000 FILE # No one can do anything - owner or root must add
                   # some permissions before any other action...
    chmod 777 * # All permissions for everyone on everything (no recursive)
    chmod --help # Or 'man chmod' for more options
	\end{bashcode}
\end{frame}

\begin{frame}{Extending permissions --- ACL}{Access control list}
	\label{acl}
	\begin{itemize}
		\item By default, it is not possible to give specific permission to the user who is not owner, nor member of group owning the file
		\item In ext4 FS it has to be turned on manually (usually it is by default), it is part of Btrfs, XFS and ZFS
		\item Command \texttt{getfacl} lists those extra permissions, \texttt{setfacl} sets
		\item \alert{When in use, \enquote{basic} tools listing permissions (e.g. \texttt{ls}~-\texttt{l}, ACL in use is marked by \texttt{+} after permissions --- next slide) sometimes do not show correct result and permissions may work unexpectedly}
		\item Important especially in network environment with many users
		\item If intensively used, \texttt{ls} -\texttt{l} sometimes doesn't show correct permissions
		\item If not in use on server (like e.g. on CESNET data storage), relatively high number of groups is required to be able to correctly setup sharing permissions
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{ACL examples}
	\begin{bashcode}
    getfacl FILE # get ACL for FILE:
    # file: dokumenty
    # owner: zeisek # Correct
    # group: zeisek # Correct
    user::rwx       # Correct
    user:nasik:r-x  # This is not seen from 'ls -l' output below!
    group::r-x      # This group has only one memebr, this is fine
    mask::r-x
    other::---      # Correct
    ls -l FILE # Compare this and previous output (This might be wrong!):
    drwxr-x---+  2 zeisek zeisek     6 17. zář 20.40 dokumenty/
    setfacl -m u/g:USER/GROUP:r/w/x FILE # Add for USER/GROUP r/w/x right
    # E.g. recursively add read permission to user 'arabidopsis_data' to
    # folder 'dokumenty/arabidopsis' (no extra group is required)
    setfacl -mR u:arabidopsis_data:r dokumenty/arabidopsis
    setfacl -R ... # Recursive (including subdirectories)
    setfacl -b FILE # Remove all ACL from FILE
	\end{bashcode}
\end{frame}

\begin{frame}{Set default permissions for new files}
	\begin{itemize}
		\item \texttt{umask} sets implicit permissions for newly created files for user
		\item Syntax is similar to \texttt{chmod}, but reverse (e.g. \texttt{027} keeps all rights for owner, for group only reading and nothing for others)
		\begin{itemize}
			\item \texttt{umask} number \textbf{removes} certain permissions
		\end{itemize}
		\item \texttt{umask 027} (or other number) is typically set in file \texttt{$\sim$/.bashrc}
		\begin{itemize}
			\item \texttt{$\sim$} means user's home directory
			\item \texttt{.bashrc} is user's configuration for BASH
		\end{itemize}
		\item Typically used in network environment
		\item Set with care --- new permissions will have plenty of consequences --- different are typically needed for web pages, private files, shared files,~\ldots
		\item \texttt{umask} work recursively for all new files in user home directory --- it is not possible to set new implicit rules for particular directory
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Other permissions}
	\begin{itemize}
		\item \texttt{sticky bit} --- new directory/file in shared directory (where everyone can write) will be deletable only by owner (typically in \texttt{/tmp})
	\end{itemize}
	\begin{bashcode}
    chmod +t somedirectory
    ls -la /
    drwxrwxrwt 22 root root 800 21. jan 18.20 tmp # "t" marks it
	\end{bashcode}
	\begin{itemize}
		\item \texttt{setgid} --- application can have root permission even it was launched by normal user
	\end{itemize}
	\begin{bashcode}
    chmod u+s someapplication
    ls -al /bin/passwd
    -rwsr-xr-x 1 root shadow 51200 25. zář 08.38 /usr/bin/passwd # Note "s"
	\end{bashcode}
	\begin{itemize}
		\item \texttt{chattr} --- change of advanced attributes on Linux FS
		\item Mostly, there is no need to modify them
	\end{itemize}
	\begin{bashcode}
    chattr -RVf -+=aAcCdDeijsStTu files
    man chattr # See explanation of attributes
    lsattr # List extended attributes
	\end{bashcode}
\end{frame}

\subsection{Text}

\begin{frame}{It \textbf{is} important to select \textbf{good} text editor\ldots}
	\begin{center}
		\includegraphics[width=\textwidth-1cm]{real_programmers.png}
	\end{center}
	\begin{flushright}
		\url{https://xkcd.com/378/}
	\end{flushright}
\end{frame}

\begin{frame}{Importance of good text editor}{Can your text editor\ldots ?}
	\label{editors}
	\begin{multicols}{2}
		\begin{itemize}
			\item Show syntax highlight
			\item Show line numbers
			\item Show space between brackets
			\item Open any encoding and EOL
			\item Fold source code
			\item Show line breaks
			\item Mark lines
			\item Open multiple files
			\item Advanced search and replace
			\item Use regular expressions
			\item Make projects, add notes
			\item Use command line
			\item Check spelling
			\item Debug source code
			\item And more\ldots
		\end{itemize}
	\end{multicols}
	\begin{multicols}{4}
		\begin{itemize}
			\item \href{https://kate-editor.org/}{Kate}
			\item \href{https://www.kde.org/applications/utilities/kwrite/}{KWrite}
			\item \href{https://www.vim.org/}{Vim}
			\item \href{https://en.wikipedia.org/wiki/Emacs}{GNU Emacs}
			\item \href{https://www.geany.org/}{Geany}
			\item \href{http://bluefish.openoffice.nl/}{Bluefish}
			\item \href{https://wiki.gnome.org/Apps/Gedit}{Gedit}
			\item \href{https://notepad-plus-plus.org/}{Notepad++}
			\item \href{https://www.sublimetext.com/}{Sublime}
			\item \href{https://atom.io/}{Atom}
			\item \href{https://www.nano-editor.org/}{Nano}
			\item And \href{https://en.wikipedia.org/wiki/List_of_text_editors}{more}\ldots
		\end{itemize}
	\end{multicols}
\end{frame}

\begin{frame}{Text and text --- differences among operating systems}
	\label{eolenc}
	\begin{itemize}
		\item Windows and UNIX have different internal symbol for end of line (\href{https://en.wikipedia.org/wiki/Newline}{new line}) --- EOL
		\begin{itemize}
			\item UNIX: LF (\texttt{\textbackslash n})
			\item Windows/DOS: CR+LF (\texttt{\textbackslash r\textbackslash n})
			\item Mac v. < 9: CR (\texttt{\textbackslash r}) (Mac up to 9~wasn't UN*X, since OS~X it is)
		\end{itemize}
		\item Good text editor can open correctly any EOL, but for example execution of script written in Windows will probably fail on Linux
		\item Different systems use different encoding
		\begin{itemize}
			\item UNIX: mainly UTF-8 (Unicode, universal), UTF-16 for Asian languages
			\item Windows: win-cp-125X (variants according to region)
			\item Older UNIX: ISO-8859-X (variants according to region)
			\item Other much less common (historical) types
			\item Important mainly for accented characters
		\end{itemize}
		\item Text editors can usually open any encoding, but automatic detection commonly fails --- set it manually
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Converting the text}{Prevent bad display and weird errors when launching scripts}
	\begin{bashcode}
    unix2dos textfile # Convert text file from UNIX to Windows EOL
    unix2mac textfile # Convert text file from UNIX to old Mac EOL
    dos2unix textfile # Convert text file from Windows to UNIX EOL
    mac2unix textfile # Convert text file from old Mac to UNIX EOL
    unix2dos --help # More information about usage, include encoding
    # Converts encoding of input file (ISO-8859-2) to outfile in UTF-8
    iconv -f ISO-8859-2 -t UTF-8 infile.txt > outfile.txt
    iconv -l # List of available encoding to convert
    iconv --help # More information about usage
    enca -h # See usage of another encoding tool
    recode CP1250..UTF-8 textfile # Convert encoding from CP-1250 to UTF-8
    recode ../CR-LF textfile # Convert EOL from UNIX to Windows
    recode --help # More information about usage; recode is deprecated
	\end{bashcode}
	\begin{itemize}
		\item macOS uses same encoding and EOL as Linux (and rest of UNIX world), so there are no problems with compatibility
		\item Launching of bash script written on Windows on Linux/macOS will probably fail (because of different EOL)
	\end{itemize}
\end{frame}

\section{Command line}

\begin{frame}{Command line}
	\tableofcontents[currentsection, sectionstyle=show/hide, hideothersubsections]
\end{frame}

\begin{frame}{Launching commands and scripts}
	\begin{itemize}
		\item Parameters of commands are separated by space and preceded by one or two dash(es)
		\item Parameter -\texttt{h} or -{-}\texttt{help} usually gives help for particular command
		\item Getting help with \texttt{man} command
		\begin{itemize}
			\item \texttt{man somecommand}
			\item Arrows to move up and down, \texttt{q} to quit
			\item Type \texttt{/} and type text and hit Enter to search --- next hit by \texttt{n}, quit search by ESC (twice)
			\item Command \texttt{info} more advanced --- type \texttt{?} for help
		\end{itemize}
		\item Parameters can be combined, order doesn't matter (same variants: \texttt{ls}~-\texttt{la}; \texttt{ls}~-\texttt{al}; \texttt{ls}~-\texttt{a}~-\texttt{l}; \texttt{ls}~-\texttt{l}~-\texttt{a})
		\item \enquote{Long} parameters (-{-}\texttt{XXX}) must stay separated
		\item Commands must be in PATH (slide~\ref{PATH}) --- actual directory isn't
		\begin{itemize}
			\item If the script is is current directory, use \texttt{./script.sh} or full path
		\end{itemize}
		\item Custom scripts must have execute permission (\texttt{chmod +x script.sh})
	\end{itemize}
\end{frame}

\begin{frame}{macOS and Homebrew}
	\label{homebrew}
	\begin{itemize}
		\item macOS contains outdated versions of many command line utilities with limited functionality comparing to what we are going to use
		\item Several projects provide Linux style way of installation and update of various (not only) command line tools, probably the best is \href{https://brew.sh/}{Homebrew}
		\item Homebrew contains also plenty of scientific packages, there is also specialized similar \href{https://brewsci.github.io/homebrew-bio/}{source for bioinformatics}
		\item Tools installed via Homebrew are installed into \texttt{/usr/local} not to interact with system packages
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Working with Homebrew}
	\begin{bashcode}
    # Install compilation tools
    xcode-select --install
    # Install Homebrew
    /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/
      Homebrew/install/master/install)"
    brew help # Basic help
    # Install updated basic UNIX tools
    brew install coreutils gnu-sed gawk grep bash gcc make wget dos2unix
    brew list # List of installed packages (brew formulae)
    brew info FORMULA # Information about particular formula
    brew search KEYWORD # Search for applications
    brew update # Update Homebrew
    brew upgrade # Update all packages installed by Homebrew
    brew uninstall FORMULA # Remove Homebrew package (formula)
    brew cleanup # Cleaning after uninstallation
    # Completely remove Homebrew (after uninstallation of all formulae)
    ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/
      install/master/uninstall)"
	\end{bashcode}
\end{frame}

\subsection[SSH]{SSH --- secure shell and screen}

\begin{frame}[fragile]{Login to remote server}{SSH --- secure shell --- encrypted connection}
	\label{ssh}
	\begin{multicols}{2}
		\begin{bashcode}
    ssh remoteUser@remote.server.cz
    # When logging first time, check
    # and confirm fingerprint key
    yes # And press Enter
    # Type remote user's password
    # (nothing is shown when typing)
    # Confirm by Enter
		\end{bashcode}
		\begin{itemize}
			\item Our toy server: user names from \texttt{cu01} to \texttt{cu20}
		\end{itemize}
		\begin{bashcode}
    ssh cuXY@vyuka.natur.cuni.cz
		\end{bashcode}
		\begin{itemize}
			\item If fingerprint key changes, ssh complains a~lot --- possible \href{https://en.wikipedia.org/wiki/Man-in-the-middle_attack}{man in the middle attack}
			\item From Windows use \href{https://www.putty.org/}{Putty}
		\end{itemize}
		\begin{center}
			\includegraphics[height=6cm]{putty.png}
		\end{center}
	\end{multicols}
\end{frame}

\begin{frame}{Screen}{Split terminal or keep task running after logging off}
	\begin{itemize}
		\item When you log off or network connection is broken, running tasks for particular terminal usually crash
		\item Sometimes number of connections is limited
		\item \texttt{screen} is solution --- virtual terminals
		\item Launch \texttt{screen} to start new screen terminal, read some info, confirm by \textbf{Space key} or \textbf{Enter}
		\item To detach from the screen press \texttt{Ctrl+A, D} --- screen is still running in background --- you can even log off
		\item To return back to running screen use \texttt{screen} -\texttt{r} --- if only one screen is running, you get back to it
		\item If more screens are running, use \texttt{screen} -\texttt{r 1234} (the number is seen from \texttt{screen} -\texttt{r})
		\item To cancel running screen press \texttt{Ctrl+D} (or type \texttt{exit} or \texttt{logout})
	\end{itemize}
\end{frame}

\begin{frame}{SSH and screen practice}
	\begin{center}
		\includegraphics[height=1.75cm]{sshterm.png}
	\end{center}
	\begin{block}{Tasks}
		\begin{enumerate}
			\item Login via SSH to \texttt{vyuka.natur.cuni.cz} and launch \texttt{screen}.
			\item Run commands \texttt{pwd}, \texttt{whoami} and \texttt{ls} -\texttt{la}. What do they show?
			\item Detach from screen and logout from the server.
			\item Login again to the server. Is it same or different process? Why?
			\item Reattach to the screen --- same state as before logout from server.
			\item Practice tasks with file names (slide~\ref{filenames})
			\item Close screen session and logout from the server.
		\end{enumerate}
	\end{block}
\end{frame}

\subsection[SH]{BASH and others}

\begin{frame}{The shell}
	\begin{itemize}
		\item Many names, many ways how to get it, still the same thing
		\item Fish --- friendly interactive shell --- the command line interface
		\item Terminal (console)
		\begin{itemize}
			\item Originally machine used for connection to remote server
			\item System uses old fashioned terminal for inner purposes
			\begin{itemize}
				\item From GUI available using \texttt{Ctrl+Alt+F1} to \texttt{F12}
				\item Changing terminals using \texttt{Alt+F1} to \texttt{F12}
				\item Return back to GUI using \texttt{Alt+F7}
				\item Some are used for log outputs etc.
			\end{itemize}
			\item Nowadays used \enquote{indirectly} with special applications (\enquote{emulators})
		\end{itemize}
		\item Terminal emulator
		\begin{itemize}
			\item Application used to get the \enquote{terminal} and work in command line
			\item Every GUI has some --- \href{https://konsole.kde.org/}{Konsole}, \href{https://yakuake.kde.org/}{Yakuake}, \href{https://invisible-island.net/xterm/}{XTerm}, \href{https://wiki.gnome.org/Apps/Terminal}{Gnome Terminal}, \href{http://guake.org/}{Guake}, \href{https://docs.xfce.org/apps/terminal/start}{XFCE Terminal}, \href{https://wiki.lxde.org/en/LXTerminal}{LxTerminal},~\ldots
			\item Commonly allow appearance customization --- font, colors, background, style of notifications,~\ldots
			\item Launch as many copies as you need (usually allow tabs for easier work)
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{The command line can has various look and feel\ldots}{Change colors, font size, etc. for your terminal to like it more and work comfortably}
	\includegraphics[width=\textwidth]{terminals.png}
\end{frame}

\begin{frame}{BASH and others}
	\begin{itemize}
		\item Shell (\textbf{sh}) --- feature rich scripting programming language --- general specification, several variants
		\item So called POSIX shell --- Portable Operating System Interface --- transferable among hardware platforms (and UNIX systems)
		\item \textbf{Interpreter of our commands inserted into command line}
		\item \textbf{BASH} --- Bourne again shell
		\begin{itemize}
			\item Probably the most common shell, based on original \texttt{sh}, respecting original specification, adding new features
			\item We will use it
		\end{itemize}
		\item Other variants: \textbf{csh} (syntax influenced by C), \textbf{ksh} (younger, backward compatible with bash), \textbf{zsh} (extended bash), \textbf{ash} (mainly in BSD)
		\item There are some differences in syntax and features
		\item Language suitable for easy scripting and system tasks, not for \enquote{big} programming, neither for graphical applications
	\end{itemize}
\end{frame}

\begin{frame}{Nice BASH features for easier work (selection)}
	\begin{itemize}
		\item Arrows up and down list in the history of commands
		\item List whole history by command \texttt{history}
		\item \texttt{Ctrl+R} --- reverse search in history --- type to search last command containing typed characters
		\item \texttt{TAB} --- list command and files starting by typed characters
		\item \texttt{Home}/\texttt{End} --- go to beginning/end of the line
		\item \texttt{Ctrl+L} --- clear screen (like \texttt{clear} command)
		\item \texttt{Ctrl+Shift+C}/\texttt{V} --- copy/paste the text
		\item \texttt{Ctrl+C} --- cancel running task
		\item \texttt{Ctrl+D} --- log out (like commands \texttt{exit} or \texttt{logout})
		\item \texttt{Ctrl+U} --- move text before cursor into clipboard
		\item \texttt{Ctrl+K} --- move text after cursor into clipboard
		\item \texttt{Ctrl+left/right arrow} --- skip words
		\item \texttt{Ctrl+T} --- flip current and left character
		\item \texttt{Ctrl+X+E} --- start text editor in current directory
	\end{itemize}
\end{frame}

\begin{frame}{Places to store BASH settings}
	\begin{itemize}
		\item \texttt{/etc/bash.bashrc} --- System wide BASH settings --- can be overridden by user's configuration
		\item \texttt{$\sim$/.bashrc} --- File is loaded each time user creates new session (typically opens new terminal window)
		\item \texttt{$\sim$/.bash\_profile} --- Used specifically (not in every system) when user is using remote connection (e.g. SSH)
		\item \texttt{/etc/profile} --- System wide profile file --- can be overridden by user's configuration
		\item \texttt{$\sim$/.profile} --- Settings loaded when user logs-in (mainly for language settings), sometimes used by remote connections
		\item \alert{Note:} BASH scripts are non-interactive shells --- they do not read settings above --- there are no aliases,~\ldots{ }but they inherit some settings (PATH, language,~\ldots) and they can read global variables
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{BASH settings (popular examples)}{Write them into BASH configuration file}
	\begin{itemize}
		\item In any text editor open \texttt{$\sim$/.bashrc} and edit it
		\item Behavior of BASH can be set to fit user's needs
		\item Terminal emulators allow to set custom fonts and colors,~\ldots
	\end{itemize}
	\begin{bashcode}
    # More colors for outputs
    eval "$(dircolors -b)"
    # Ignore repeated entries in bash history (stored in ~/.bash_history)
    HISTCONTROL='ignoreboth'
    # Maximal length (number of lines) of bash history (~/.bash_history)
    HISTFILESIZE='100000'
    # Following two settings save history from multiple terminals
    # Normally, only history from last time opened terminal is kept
    shopt -s histappend # Append to history, don't overwrite it
    # Save and reload the history after each command finishes
    export PROMPT_COMMAND="history -a; history -c; history -r;
      $PROMPT_COMMAND" # Note its recursive behavior
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{Aliases and BASH settings}{Alias is short cut --- instead of very long command write short alias}
	\begin{bashcode}
    # Define new alias
    alias ll="ls -l"
    # Since now, instead of "ls -l" we can write just "ll"
    # To make the change above permanent, write it into ~/.profile or
    # ~/.bash_profile or ~/.bashrc and reload the configuration by e.g.
    source ~/.bashrc # to reload BASH settings
    # If there are many aliases, they can be stored e.g. in ~/.alias
    test -s ~/.alias && . ~/.alias || true # Check for extra alias file
    # Popular aliases
    alias ls="ls --color=auto" # Make output of ls colored
    alias l="ls -la" # Long list (add details) with hidden files
    # Popular settings in ~/.bashrc (influencing bash, not other shells)
    alias grep='grep --color=auto' # Enable color in grep
    # Always human readable output of df (disk free)
    alias df='df -h'
    # Easier history listing
    alias his="history | grep" # Use e.g. 'his ls' to list last 'ls' usage
    # Add aliases pointing to software installed outside PATH, ...
	\end{bashcode}
\end{frame}

\begin{frame}{BASH globing and wildcards}
	\label{globbing}
	\begin{itemize}
		\item BASH itself doesn't recognize regular expressions --- it's wildcards have some of functions of regular expressions (from slide~\ref{regexp}) and can look similarly, but behave differently --- Do not confuse!
		\item \texttt{?} --- Replaces any single character
		\item \texttt{*} --- Replaces any number of any characters (\texttt{ls a*} lists all files starting with \enquote{a})
		\item \texttt{[]} --- Range or a~list --- \texttt{[abcdef]} and \texttt{[a}-\texttt{f]} are same
		\item \texttt{[!\ldots]} --- Reverse previous case (\texttt{!}) --- any character except those listed
		\item \texttt{\{\}} --- Expansion (terms inside are separated by commas \texttt{,}) --- all possible combinations (see next slide for examples)
		\item \texttt{\textbackslash} --- Escapes following character and it doesn't have its special meaning (e.g. \texttt{\textbackslash *} means literally asterisk \texttt{*} and not \enquote{any number of any characters} as usually)
		\item For details see \texttt{man 7~glob} and \texttt{man 7~regex}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Brace expansion and quotes}
	\begin{bashcode}
    echo a{p,c,d,b}e # ape ace ade abe - all combinations
    echo {a,b,c}{d,e,f} # ad ae af bd be bf cd ce cf - all combinations
    ls *.{jpg,jpeg,png} # expansion to *.jpg *.jpeg *.png, same as
    ls *.jpg *.jpeg *.png
	\end{bashcode}
	\begin{itemize}
		\item Text in single quotes (\texttt{'\ldots'}) preserves the literal value of each character within the quotes
		\item Tex tin double quotes (\texttt{"\ldots"}) preserves the literal value of all characters within the quotes, with the exception of dollar (\texttt{\textdollar}), back tick (\texttt{\textasciigrave}) and back slash (\texttt{\textbackslash})
		\item A~double quote may be quoted within double quotes by preceding it with a~backslash (\texttt{\textbackslash"} means literally \enquote{double quote})
		\item Text between back ticks (\texttt{\textasciigrave\ldots\textasciigrave}) or within \texttt{\$\{\ldots\}} will be evaluated and then used as command or argument (see next slide for examples)
	\begin{itemize}
		\item Syntax with back ticks is deprecated, keep using \texttt{\$\{\ldots\}} instead
	\end{itemize}
	\end{itemize}
\end{frame}

\subsection{Directories}

\begin{frame}[fragile]{Directories}
	\begin{bashcode}
    pwd # Print working directory - where we are right now
    cd # Change directory (just "cd" or "cd ~" goes to home directory)
    cd .. # One directory up; cd ../..; cd ../../another/directory/
    cd relative/path/from/current/position # Go to selected directory
    cd /absolute/path/from/root # Absolute path starts by "/"
    tree # Tree like hierarchy of files and directories
    tree -d # List only directories; see tree --help
    tree -L 2 # Only up to second level; combine: tree -d -L 3
    du -sh # Disk usage by current directory, -s for sum, -h for nice units
    mkdir NewDirectory # Make directory
    rmdir DirectoryToRemove # Remove empty directory
    ls # List directory content
       # Try parameters -l, -a, -1, -F, -h (with -l or -s), --help
    rm -r # Recursive delete - remove also non-empty directories
    mv from to # Move files/directories (also for renaming)
    cp from to # Copy, -r (recursive, including subdirectories)
               # -a (keeps all attributes), -v (verbose)
    file somefile # Information about questioned file (what it is, ...)
    xdg-open somefile # Open file by graphical application as in GUI
	\end{bashcode}
\end{frame}

\begin{frame}[allowframebreaks]{Tasks on the remote server}
	\begin{enumerate}
		\item Login via SSH to \texttt{vyuka.natur.cuni.cz}.
		\item Get your path by \texttt{pwd}.
		\item Go to \texttt{/home/scripts\_data} (with \texttt{cd}) and explore its content (\texttt{ls}).
		\item List permissions in \texttt{/home/scripts\_data} (slide~\ref{permissions}). What to they show? What can you do with the content?
		\item How much space does \texttt{/home/scripts\_data} consume?
		\item Go back to home directory (by \texttt{cd}).
		\item Create new directory in your home directory (\texttt{mkdir}).
		\item Copy content of \texttt{/home/scripts\_data} into your newly created directory (\texttt{cp}).
		\item Rename that directory with scripts and data using \texttt{mv} to any custom name. Who is owner of the files in origin location and in new location? Why?
		\item Explore your home directory and its content by command \texttt{ls} and \texttt{tree} and some files by command \texttt{file}. Which hidden files and directories are there? What could it be?
		\item Change permissions of the files so that only you can read, write and execute them (\texttt{chmod}).
		\item Create other directory, see it and then remove (\texttt{rmdir}).
		\item Can you access directories of another users? Why? If yes, what are your permissions there? Explain it.
		\item What are some permissions in \texttt{/}? Why?
		\item Create directory in your home directory and share it with another user so she/he can write there anything (using e.g. \texttt{touch somefile} or \texttt{mkdir somedirectory}) (work e.g. in pairs). Use everywhere as restricted permissions as possible. Can you figure out solution with or without ACL (slide~\ref{acl})?
	\end{enumerate}
\end{frame}

\begin{frame}{Midnight Commander}
	\begin{multicols}{2}
		\begin{itemize}
			\item \texttt{mc} to launch MC
			\item Move (\texttt{F6}), copy (\texttt{F5}), delete (\texttt{F8}), files/directories
			\item Connect to SSH/(S)FTP,~\ldots
			\item Can be used with mouse
			\item Edit (\texttt{F4}) or view (\texttt{F3}) text files
			\item \texttt{F2} for quick menu
			\item \texttt{F9} for top menu
			\item And much more\ldots
			\item Impossible to live without it :-)
			\item \alert{Task:} Which of the previous tasks can you solve with it? Try it.
		\end{itemize}
		\includegraphics[height=6.5cm]{mc.png}
	\end{multicols}
\end{frame}

\subsection{Archives}

\begin{frame}{Compressing files into archives}
	\begin{center}
		\begin{tabular}{llll}
			\textbf{Archive} & \textbf{Compressing command}\\
			*.tar & tar cvf archive.tar file1 file2\\
			*.tar.gz\alert{/}*.tgz & tar czvf archive.tar.gz\alert{/}.tgz file1 file2\\
			*.tar.bz\alert{/}*.tbz\alert{/}*.tar.bz2 & tar cjvf archive.tar.bz\alert{/}.tbz\alert{/}.tar.bz2 file1 file2\\
			*.tar.xz & tar cvf - file1 file2 | lzma > archive.tar.xz\\
			*.gz & gzip file\\
			*.bz2 & bzip2 file\\
			*.xz & lzma file\\
			*.zip & zip -r archive.zip file1 file2\\
			*.rar & rar a archive.rar file1 file2
		\end{tabular}
	\end{center}
	\begin{itemize}
		\item \texttt{gzip}, \texttt{bzip2} and \texttt{lzma} are able to pack only one file --- use them together with \texttt{tar} to pack multiple files
		\item \texttt{gzip}, \texttt{bzip2} and \texttt{lzma} when used \textbf{without} \texttt{tar} \alert{move} file into archive
		\item \texttt{lzma} has excellent compression, but can be very slow
	\end{itemize}
\end{frame}

\begin{frame}{Compressing and decompressing archives}
	\begin{center}
		\begin{tabular}{llll}
			\textbf{Archive} & \textbf{Decompressing command}\\
			*.tar & tar xvf archive.tar\\
			*.tar.gz\alert{/}*.tgz & tar xzvf archive.tar.gz\alert{/}.tgz\\
			*.tar.bz\alert{/}*.tbz\alert{/}*.tar.bz2 & tar xjvf archive.tar.bz\alert{/}.tbz\alert{/}.tar.bz2\\
			*.tar.xz & lzcat archive.tar.xz | tar xvf -\\
			*.gz & gunzip archive.gz\\
			*.bz2 & bunzip2 archive.bz2\\
			*.xz & unlzma archive.xz\\
			*.zip & unzip archive.zip\\
			*.rar & unrar x archive.rar
		\end{tabular}
		\includegraphics[height=2cm]{tar.png}
		\hfill
		\url{https://xkcd.com/1168/}
	\end{center}
\end{frame}

\begin{frame}{Tasks with archives}
	\begin{enumerate}
		\item Compress (and decompress) text file \texttt{Oxalis\_HybSeq\_nrDNA\_selection\_alignment.fasta} (target enrichment sequencing data of South African \textit{Oxalis}) from \texttt{scripts\_data} with various compressing tools.
		\item Compare sizes of original file and compressed outputs.
		\item Compress (and decompress) all \texttt{foto\_oxalis\_*.jpg} (\textit{Oxalis} photos) from \texttt{scripts\_data} with various compressing tools.
		\item Compare sizes of original files and compressed outputs.
		\item Which compression tool seems to be the best? In terms of compressing ratio and time needed for compression.
		\item Is more effective compression of text files or images? Why?
		\item Why is even plain \texttt{tar} (any compression) useful with FAT disks?
	\end{enumerate}
\end{frame}

\subsection{Searching}

\begin{frame}[fragile]{Looking for files and applications}
	\begin{bashcode}
    apropos keyword # Searches for command descriptions containing keyword
    updatedb # Must be regularly launched to get "locate" to work
             # It is usually regularly launched by cron task (see further)
    locate somename # Searches for files/directories in "locate" database
    which # Full path to application (shell command)
    whereis # Path to source code, executable and man pages for the command
    # Test if executable command exists (good for scripts)
    # If "Application" is missing, script ends with error
    command -v Application >/dev/null 2>&1 || { echo >&2 "Application is
      required but not installed. Aborting."; exit 1; }
    command -v find # Behaves like which, but reliable in scripts
    type Application >/dev/null 2>&1 || { echo >&2 "Application is
      required but not installed. Aborting."; exit 1; }
    hash Application 2>/dev/null || { echo >&2 "Application is required
      but not installed. Aborting."; exit 1; }
    exit 1 # Use to be added (with various numbers) after any error to
           # send term signal 1 - for better handling of various errors.
           # Every termination has exit status number - 0 is normal exit.
           # Exit status 1 and higher number is various error.
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{Find}
	\begin{bashcode}
    find <where> <what> <what to do> # The most powerful searching tool:
    find /.. -type d/f -name XXX -print # Most common usage
	\end{bashcode}
	\begin{itemize}
		\item First \texttt{find}'s parameter is location to search --- absolute or relative, \enquote{\texttt{.}} means current directory (the only compulsory parameter)
		\item -\texttt{type} for only directories \texttt{d} or only files \texttt{f} (without this parameter, files as well as directories are looked for)
		\item -\texttt{name} of the searched files/directories supports wildcards (\texttt{*}, \texttt{?} and \texttt{[\ldots]}), see globing (slide~\ref{globbing})
		\item -\texttt{print} is default action --- prints list of results
		\item -\texttt{exec} runs some command with results (some operation, not just listing)
		\begin{itemize}
			\item All following arguments are argument of the command until \enquote{\texttt{;}} is encountered
			\item \texttt{\{\}} is replaced by the current file name being processed
			\item Those constructs might require protection by escape (\enquote{\textbackslash}) or quotes not to be expanded by shell
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Find examples (apply some of them to the toy data)}
	\begin{bashcode}
    # Find in /home/$USER/ all JPG files containing string "oxalis"
    find /home/$USER/ -name "*oxalis*.jpg" -print
    # Find in scripts_data all JPG files and resize them to 1000x1000 px
    find scripts_data -name "*.jpg" -exec mogrify -resize 1000x1000 '{}' \;
    # Another possibility with xargs (it chains commands - reads input from
    # stdin and execute command with given arguments, using all CPU threads)
    # Note in the example below -print is not needed as it is default action
    find photos/ -name "*.jpg" | xargs mogrify -resize 1000x1000
    # Find all R scripts in ~/Documents and find in them lines with "DNA"
    find ~/Documents -name *.r -print | xargs grep -nH DNA # Or
    find ~/Documents -name *.r -exec grep -nH DNA '{}' \;
    # How many directories are there in the books directory
    find books/ -type d -print | wc -l # wc -l calculate lines
    # Change permissions of all files within "files" directory to 640
    find files/ -type f -exec chmod 640 '{}' \;
    # Find all executable files within current directory and list them
    find . -executable -type f -print
    find doc/ -type d -empty -execdir rmdir {} \; # Delete empty directories
    man find # See another options. Much more...
	\end{bashcode}
\end{frame}

\begin{frame}{Searching tasks}
	\begin{enumerate}
		\item Use \texttt{locate} to find file \texttt{long\_text.txt}. Is the output absolutely correct? If not, why?
		\item Where is executable of \texttt{mc}? Why can be such information useful? Where are its libraries, data, configuration and manual?
		\item Which software is related to keywords \texttt{permission} and \texttt{compress} (use e.g. \texttt{apropos})? Use \texttt{man} to explore some of them.
	\end{enumerate}
	\begin{block}{Tasks with \texttt{find}}
		\begin{enumerate}
			\item Find all \texttt{*.vcf.gz} files in whole \texttt{/home}. Why do you get errors for some directories?
			\item Compress, see and decompress all shell scripts in your home directory.
			\item Change permissions of all content of your home directory so that no one else can access it. Consider hidden files, directories and scripts.
			\item List all directories in \texttt{/etc}.
		\end{enumerate}
	\end{block}
\end{frame}

\subsection{Variables}

\begin{frame}[fragile]{BASH expressions}
	\begin{bashcode}
    # Many operands have special meaning in BASH - must be escaped
    echo $((5 < 7)) # Is 5 smaller than 7? TRUE (1)
    echo $((3 > 4)) # Is 3 greater than 4? FALSE (0)
    echo $((16 / 3)) # Division (without decimal part)
    echo $((12 % 5)) # What remains after aritmetic division
    x=$((1 + 6)) # Result will be in 'x'
    echo $x
    x=1 # Set x to 1
    y=$x+1 # Will this add 1? Why?
    echo $y # See result
    y=$(($x + 1)) # Will this work? Why?
    echo $y # Result
    echo $(expr length "MetaCentrum and Linux") # Get length of chain
    # String of 5 characters starting at position 10 of the text
    echo $(expr substr "MetaCentrum and Linux" 10 5)
    # Does 1st chain contain 2nd chain (how long)? Get position of first hit
    echo $(expr index "GNU Linux" "Linux") # If no overlap, return value is 0
	\end{bashcode}
	\begin{itemize}
		\item \texttt{expr} works with various operands (see \texttt{man expr})
	\end{itemize}
\end{frame}

\begin{frame}{Variables in BASH}
	\begin{itemize}
		\item Variables contain various information (where to look for the executable programs, name of the computer, various settings, input files,~\ldots)
		\item Can be local (within a~script for some temporal purpose) or global --- available for all processes (and users)
		\item Names commonly written in CAPITALS (just a~costume)
		\item Popular and useful variables
		\begin{itemize}
			\item \texttt{HOME} --- location of user's home directory
			\item \texttt{HOSTNAME} --- network name of the computer
			\item \texttt{LANG} --- language settings, encoding, similarly variables \texttt{LC\_*}
			\item \texttt{PATH} --- paths where to look for applications --- all applications have to be in \texttt{PATH} or called directly (slide~\ref{PATH})
			\item \texttt{SHELL} --- shell in use (bash or something else)
			\item \texttt{USER} --- user name
			\item And many more, commonly specific for particular server
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Work with variables}
	\begin{bashcode}
    printenv # Get all environmental variables and their values
    export -p # Get all exported variables and their values
    declare -p # Get all declared variables and their values
    echo "$VARIABLENAME" # Get value of particular variable
    echo "$PATH" # Get path where to look for applications
    VARIABLE='variablevalue' # Set new variable and its value
                             # Or replace existing variable by new value
    export EDITOR=/usr/bin/vim # Set new default text editor
    LISTFILES="$(ls -1)" # Get output of command 'ls -1' into the variable
    echo "$LISTFILES" # See content of the variable LISTFILES
    export GREP_OPTIONS='--color=auto' # Colored grep (see further)
    unset VARIABLENAME # Drop variable and its value
	\end{bashcode}
	\begin{itemize}
		\item Exported variables will be lost when logging off
		\item To make variables permanent, add \texttt{export} commands into \texttt{$\sim$/.profile} or \texttt{$\sim$/.bash\_profile}, or \texttt{$\sim$/.bashrc} (according to shell and its settings)
		\item \enquote{\texttt{$\sim$}} means home directory
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{The PATH variable}
	\label{PATH}
	\begin{itemize}
		\item Lists directories (separated by colon \texttt{:}) where the current shell searches for commands
		\item If some software is installed outside standard locations, the user must specify the full path (or update the \texttt{\$PATH})
		\item In case there are two commands with the same name (e.g. \texttt{/bin/somecommand} and \texttt{/usr/bin/somecommand}), the order of directories in \texttt{\$PATH} matters --- the first occurrence is used, any possible later ignored
	\end{itemize}
	\begin{bashcode}
    # See the $PATH variable
    echo $PATH # Sample output is on the next line:
    /home/$USER/bin:/usr/local/bin:/usr/bin:/bin:/opt/bin:/sbin:/usr/sbin
    # Adding new directory to $PATH
    export PATH=$PATH:/some/new/directory # Ensure to add original $PATH
    # Do not do it in the following way - it would overwrite $PATH, and
    # there would be only the new directory (not the original content)!
    export PATH=/some/new/directory # Wrong! Old $PATH is missing!
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{Reading variables from command line and as output of another commands}{This is especially useful in scripting to read input from users or from another commands}
	\begin{bashcode}
    # Reading variable from user's input from command line
    # (some interactive script interacting with the user)
    read X # We will read new variable from input (do not use "$" here)
    10 # Type any value and press Enter
    echo $X # Get value of the variable
    10 # It works
    echo "$((1 + $X))" # Sum of 1 and variable $X
    # Output some command into variable
    Y=$(command) # Set as variable output of command
    echo $Y # Y will contain output of command
    # "command" from previous lines can be e.g.
    cat somefile.txt # Read content of somefile.txt
    WORKDIR=$(pwd)# Save current directory into variable
    ls -1 | head -n 1 # First file/directory in the current directory
    unset X # Destroy this variable
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{Variables and quotes and more}
	\begin{bashcode}
    A=abcdef # Set new variable (no special characters allowed)
    echo $A # See variable's content
    abcdef # It works
    echo '$A' # Single quotes preserve literal value
    $A # We see variable's name, not its content
    echo "$A" # Double quotes preserve literal value, except $, `, \
    abcdef # This also works
    echo `$A` # Text between back ticks is evaluated and launched
    abcdef: command not found # There is no command "abcdef"...
    echo $($A) # Same as `...`, this is now recommended way, `...` legacy
    echo "Hi, dear $USER" # Compare this and following command...
    echo 'Hi, dear $USER' # Single quotes do not evaluate variables
	\end{bashcode}
	\begin{itemize}
		\item \alert{\texttt{\textdollar}} marks variables
		\item \alert{\texttt{\textbackslash}} escapes following character --- it will not have its special meaning (space to separate arguments,~\ldots{ }--- next slide)
		\item If variable is going to contain any special character (\texttt{?}, \texttt{.}, \texttt{*},~\ldots), the value must be quoted --- \texttt{"\ldots"} allow escaping of special character or inclusion of another variables, \texttt{'\ldots'} keeps absolutely literal value
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{How quotes influence reading of variable content}
	\begin{bashcode}
    A=abcde # OK
    echo $A # abcde
    B=abcd$e # The content will be "abcde + $e" or "abcd" (if $e is missing)
    echo $B # abcd
    C=abcd\$e # \ escapes next character - it is loosing its special meaning
    echo $C # abcd$e
    D='abcd$e' # '...' keep literal value of the content
    echo $D # abcd$e
    # Next command breaks shell - incomplete quotes " - pres then Ctrl+C
    E=ab"cde # The variable should contain incomplete quotes ", it fails
    echo $E # Nothing - empty
    F=ab\"cde # \ escapes next character - it is loosing its special meaning
    echo $F # ab"cde
    G='ab"cde' # '...' keep literal value of the content
    echo $G # ab"cde
    H=abc$(echo $USER)de # See $USER to see what will be inserted in $(...)
    echo $H # abcvojtade # To add output of command into the variable
    I='...' # Needed if $I should contain spaces, quotes, `, $, ...
	\end{bashcode}
\end{frame}

\subsection[Chaining]{Input, output and their redirecting}

\begin{frame}{Chaining commands}
	\begin{itemize}
		\item \alert{\texttt{\&}} --- command will be launched in background, terminal is available for next typing: \texttt{firefox \&} (when launching graphical application, hit \textbf{Enter} afterward if there is no active command line prompt)
		\item \alert{\texttt{\&\&}} --- second command is launched only when first command exits without error (exits with status \texttt{0}): \texttt{mkdir NewDir \&\& cd NewDir}
		\item \alert{\texttt{;}} --- second command is launched regardless exit status of the first one: \texttt{kshfskcbd; hostname}
		\item \alert{\texttt{\textbraceleft\ldots\textbraceright}} --- commands within curl brackets are launched as one block
		\item \alert{\texttt{||}} --- second command is launched when first command fails (has non zero exit status):\\\texttt{cd newdir || \textbraceleft~mkdir newdir \&\& cd newdir; \textbraceright}
		\item \alert{\texttt{|}} --- pipe --- redirects standard output of one command into standard input of second command: compare \texttt{mount} and \texttt{mount | column} -\texttt{t}
		\item Behavior in shells other than bash might be little bit different
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Standard input and output and redirects}
	\begin{itemize}
		\item Standard input (\texttt{stdin}) is standard place where software takes input (keyboard and terminal) and writes results to standard output (\texttt{stdout}) --- typically monitor
		\item Standard error output (\texttt{stderr}) is target of error messages --- typically also monitor (but can be log file or so)
		\item \alert{\texttt{\textgreater}} redirects output into new place (file, device, another command,~\ldots)
	\end{itemize}
	\begin{bashcode}
    cat /etc/group # Print whole file /etc/group
    grep users /etc/group > users # Extract from /etc/group lines containing
                                  # "users" and write output into new file
    cat users # See result
	\end{bashcode}
	\begin{itemize}
		\item \alert{\texttt{\textgreater\textgreater}} adds output to the end of the file (\texttt{\textgreater} rewrites target file)
	\end{itemize}
	\begin{bashcode}
    grep root /etc/group >> users # Add new information into existing file
    cat users # See result
	\end{bashcode}
	\begin{itemize}
		\item \alert{Task:} Practice chaining and redirects from previous and this slide. What is it good for?
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Redirects and pipes}
	\label{pipe}
	\begin{itemize}
		\item \texttt{/dev/null} --- \enquote{black hole} --- can discard anything
	\end{itemize}
	\begin{bashcode}
    command 2> /dev/null # Discard only errors (note "2" for errors only)
    command > /dev/null # Discard all output (no logging or onscreen output)
	\end{bashcode}
	\begin{itemize}
		\item \texttt{/dev/stdin} --- standard input
		\begin{itemize}
			\item Typically keyboard
			\item In case application reads files, not from standard input:
		\end{itemize}
	\end{itemize}
	\begin{bashcode}
    echo "Žluťoučký kůň úpěl" | iconv -f utf-8 -t cp1250 /dev/stdin
	\end{bashcode}
	\begin{itemize}
		\item \texttt{/dev/stdout} --- standard output
		\begin{itemize}
			\item Typically screen, commonly redirected into file
			\item We wish to see errors which would be discarded otherwise:
		\end{itemize}
	\end{itemize}
	\begin{bashcode}
    command 2> /dev/stdout # Errors go to screen (typically), not to log
	\end{bashcode}
	\begin{itemize}
		\item \texttt{/dev/stderr} --- standard error output
		\begin{itemize}
			\item Typically screen or log file, right place to send errors to:
		\end{itemize}
	\end{itemize}
	\begin{bashcode}
    echo "error" > /dev/stderr
    command 2> /dev/stderr # Errors go to standard error log
	\end{bashcode}
	\begin{itemize}
		\item \texttt{|} --- pipe --- basic redirecting method --- standard output of one command to standard input of another command
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Redirects of standard input and output I}
	\begin{block}{Tasks with redirects of standard input/output}
		\begin{itemize}
			\item Try everything on this and following slide
			\item Be sure to understand the redirects and differences among the variants
			\item Try to figure out some other example regarding your practical needs
		\end{itemize}
	\end{block}
	\begin{bashcode}
    # Write directory listing into text file
    # If file directory_listing.txt exists, will be overwritten
    ls -la > directory_listing.txt
    cat directory_listing.txt # See result (same as running "ls -la")
    # If file directory_listing.txt exists, new content will be appended
    ls -la >> directory_listing.txt # See result 'cat directory_listing.txt'
    # We are outputting 'ls -lh' to 'awk' and not to screen, printing only
    # selected columns, and parsing with 'column -t' for tabular display
    ls -lh # Compare outputs of the 3 commands starting with 'ls -lh'
    ls -lh | awk '{ print $NF, " ", $5}' # See further more info about awk
    ls -lh | awk '{ print $NF, " ", $5}' | column -t
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{Redirects of standard input and output II}{Try everything and be sure to understand}
	\begin{bashcode}
    # Add error output to the end of standard output file
    # Note: In the examples below command "commandX" does not exist -
    # it produces error "command not found" to be recorded by the log
    # and because of redirect, the error is not shown in the terminal.
    command > outputfile.log 2>&1 # Example:
    { commandX; ls; } > outputfile.log 2>&1
    cat outputfile # See result
    # Compare with following. What is the difference?
    { commandX; ls; } > outputfile.log # Where does error and output go?
    # Compare two following commands. What is the difference?
    { commandX; ls; } > outputfile.log 2>&1 # Inspect outputfile.log
    { commandX; ls; } >> outputfile.log 2>&1 # Inspect outputfile.log
    # Add error output to the error log text file
    command >> outputfile.log 2>error.log # Example:
    { commandX; ls; } >> outputfile.txt 2>error.log
    cat outputfile.txt # See results
    cat error.log # See results
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{Examples of redirects and pipes when working with molecular data}
	\begin{bashcode}
    # Extract and sort depth of coverage (how many times was each position
    # sequenced) in genomic VCF with multiple individuals
    zcat arabidopsis.vcf.gz | grep -o "DP=[0-9]\+" | sort | less
    # Convert DNA sequence from FASTQ to FASTA (two of many options)
    # (discard FASTQ quality scores and keep only the sequence and its name)
    bzcat Oxalis_hirta_R1.fastq.bz2 | sed -n '1~4s/^@/>/p;2~4p' > \
      Oxalis_hirta_R1.fasta
    bzcat Oxalis_hirta_R2.fastq.bz2 | awk '{if(NR%4==1)
      {printf(">%s\n",substr($0,2));} else if(NR%4==2) print;}' > \
      Oxalis_hirta_R2.fasta
    # See both sequences in one view
    less Oxalis_hirta_R{1,2}.fasta
    # Mapping of trimmed Illumina FASTQ reads to reference FASTA sequence
    # and creation of BAM containing the alignment (reference and mapped
    # reads, one BAM for each sample)
    bwa mem reference.fasta input_R1.fastq input_R2.fastq | samtools view \
      -bu | samtools sort -l 9 -o mapped.bam
	\end{bashcode}
\end{frame}

\subsection[HW, sys and ps]{Information and processes}

\begin{frame}[fragile]{Which system are we using?}
	\begin{bashcode}
    uname -a # Information about Linux kernel (version, ...)
    lsb_release -a # Information about Linux distribution release
    cat /etc/os-release # Similar to above command
    lscpu # Information about CPU
    cat /proc/cpuinfo # Raw list of information about CPU
    lsusb # List of devices on USB
    lspci # List of PCI devices (graphic card, network card, ...)
    lspci | grep -i vga # Get information about graphical card
    lshw # Complete list of hardware
    lshw -C memory # Information about RAM
    hwinfo # Complete list of hardware
    hwinfo --network # Information about network devices
    free -h # Available memory (RAM) and swap, -h for nice units
    df -h # Free space on disk partitions, -h for nice units
    lsmod # List loaded kernel modules
    uptime # How long is the system running, number of users, average load
    date # Date and time - plenty of options for formatting
    mount # Information about mounted file systems
    findmnt # Display mounted devices in tree structure
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{Processes --- every running program has its own process ID}
	\begin{bashcode}
    htop # Nice listing of processes (better version of top), quit using "q"
    pstree # See running processes with child processes, recursively
    pgrep application # Return PID (process ID) of application
    ps # processes related to actual terminal
    ps x # All user's processes
    ps aux # All processes
    # kill (terminate) process by name or process ID (PID)
    # Find which PID has application to terminate
    pgrep geany
    14639
    # Kill (stop by SIGTERM) selected application according to above PID
    kill -SIGTERM 14639 # SIGTERM is "nice" termination, SIGKILL "brutal"
    kill -SIGTERM $(pgrep geany) # Two above commands in one step; note $()
    killall -SIGTERM geany # Select by name (more processes with same name)
    # nice - how much resources will task use: from -20 (high priority - not
    # "nice" process) to +19 (low priority - very "nice" process), default 0
    nice -n 7 hard_task.sh # set priority 7 for newly launched task
    renice 15 16302 # Change priority of PID 16302 to 15
    sudo renice 15 16302 -u USER # Change priority of USER's process
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{Users}
	\begin{bashcode}
    whoami # What is my user name
    id # Information about current user (user ID and group IDs)
    who # Who is logged in
    w # Who is logged in, more information
    users # Plain list of currently logged users
    finger # Information about users on current terminals
    last # Last logged-in users
    passwd # Change password
    passwd USER # Change USER's password
    groups # List your groups
    # Following commands to manage users and groups do not have to work
    # on all systems - depends on authentication methods used
    useradd newuser # Add new user
    usermod --help # Modify user, see possible modifications
    userdel user # Delete user
    groupadd newgroup # Add new group
    groupmod --help # Modify group, see possible modifications
    groupdel group # Delete group
	\end{bashcode}
\end{frame}

\begin{frame}{Tasks regarding hardware, information and processes}
	\begin{enumerate}
		\item Change your password on the remote server and/or virtual machine.
		\item Who is and was recently logged in to the remote server?
		\item Which information about hardware can you get from your local computer (if you are running Linux) and from course server? Why could such information be useful?
	\begin{enumerate}
		\item Which disks are mounted?
		\item How many memory (RAM) slots are occupied and what is memory size?
	\end{enumerate}
	\item Find your user ID on local computer and remote server? Do you think this has any implications when copying files from your local computer to server and back?
	\item Terminate from command line some running graphical application. What is difference between \texttt{kill} and \texttt{killall}?
	\item Change priority of some running (graphical) application.
	\item Which applications are consuming the most resources (CPU, RAM)?
	\end{enumerate}
\end{frame}

\subsection{Network}

\begin{frame}[allowframebreaks]{Network protocols}
	\begin{itemize}
		\item Every network communication protocol (e.g. browsing web or Skype) has its own distinct port (\enquote{door to access target computer}) --- it must be opened (by firewall)
		\item SSH --- secure shell --- command-line connection to remote server to work there (port 22), slide~\ref{ssh}
		\item Telnet --- old deprecated insecure version of SSH, never ever use it (port 23), only low-quality electronics still sometimes use it
		\item FTP --- file transfer protocol --- outdated, no encryption (port 21), slowly replaced by FTPS or SFTP/SCP
		\begin{itemize}
			\item Sometimes used only for download, e.g. \url{ftp://ftp.ebi.ac.uk/pub/} or \url{ftp://botany.natur.cuni.cz/}
		\end{itemize}
		\item FTPS --- FTP with added connection encryption for higher security (port 21), common
		\item SFTP --- FTP over SSH --- common, secure (port 22), slide~\ref{transfers}
		\item SCP --- secure copy --- uses SSH, but has restricted possibilities, common, secure (port 22), slide~\ref{transfers}
		\item NFS --- network file share/server --- very common in UNIX world (commonly used e.g. by CESNET MetaCentrum and \href{https://du.cesnet.cz/en/navody/nfs/start}{data storage} --- \href{https://du.cesnet.cz/cs/navody/nfs/start}{česky}), commonly used to permanently connect to network server, share directories, etc. (port 20049), slide~\ref{netfs}
		\item webDAV --- file transfer over web (using WWW server) --- not so common, but good (port 80 or 443 --- same as WWW), slide~\ref{netfs}
		\begin{itemize}
			\item Accompanied by calDav and cardDav to share calendars and address books over the network
			\item Used e.g. by ownCloud/nextCloud (also \href{https://du.cesnet.cz/en/navody/owncloud/start}{provided by CESNET} --- \href{https://du.cesnet.cz/cs/navody/owncloud/start}{česky}) --- tool to synchronize and share files etc, similar to Dropbox or Google Drive
		\end{itemize}
		\item SAMBA --- UNIX connection to Microsoft network shares (port 5445), slide~\ref{netfs}
		\item web --- \enquote{The Internet} for most of users (port 80 or encrypted 443)
		\item IMAP (port 143 or 993) and SMTP (port 25 or 465) to connect to e-mail server and send mails
		\item Messaging protocols like XMPP (Jabber and derived services like Google Talk or Facebook Messenger), IRC, ICQ, Skype,~\ldots
		\item And much more (see \texttt{/etc/services})\ldots
		\item Port number can be changed in configuration of respective server service
		\item All firewalls on the way must allow communication on given port --- some ports are commonly filtered in restrictive Wi-Fi networks or totalitarian countries
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Basic network information and testing}
	\begin{bashcode}
    hostname # Get name of the computer
    ping web.natur.cuni.cz # Ping host. Is it alive? Cancel by Ctrl+C
    traceroute www.metacentrum.cz # Get route (path) to the host
    mtr hostname # Combines ping and traceroute, quit with "q"
    ip a s # Information about all network devices (MAC, IP address, ...)
    ifconfig -a # Older version of above command
    iwconfig # List of wireless network interfaces
    ip r # Show routes
    nc -vz web.natur.cuni.cz 22 # Does SSH work on the host?
      # verbose (-v), scan (-z), host, port number (22 for SSH, can be any)
    man nc # See for more information; "nc" is alias for "netcat"
    netstat -atn # Information about all network connections
    netstat -ntplu # Show open TCP/UDP ports
    netstat -anp # Show active connections
    netstat -h # See for explanation of 3 above examples
    # If using nmap at faculty, firewall disconnects you for 10 minutes!
    nmap -r someserver.cz # Scan someserver.cz for opened ports
    nmap botany.natur.cuni.cz --script ssh-hostkey # See SSH key
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{Connecting file systems on remote servers}
	\label{netfs}
	\begin{itemize}
		\item Target mount point must exist before mounting
		\item Servers can be accessed by IP address or hostname
	\end{itemize}
	\begin{bashcode}
    # Mount Windows server (requires packages samba and cifs)
    mount.cifs //windows.server.cz/Some/Directory /mnt/win -o \
      credentials=/path/to/password.file,uid=USER,gid=GROUP
    # "password.file" contains login credentials to Windows server:
    username=user.name
    password=TopSecretPassword1
    domain=DOMAINNAME
    # Mounting remote server over SSH (sshfs package must be installed)
    sshfs USER@vyuka.natur.cuni.cz:/some/dir /local/mount/point
    fusermount -u /mount/point # Disconnect SSHF
    # Mount NFS share (NFS is common protocol in UNIX world)
    mount -t nfs some.server.cz:/shared/directory /local/directory
    # Mount webDAV folder (requires package davfs2 to be installed)
    mount -t davfs https://owncloud.cesnet.cz/directory /local/directory
    umount /mount/point # Disconnect CIFS/SAMBA, NFS, webDAV, ...
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{Transferring files from/to remote server}
	\label{transfers}
	\begin{itemize}
		\item \texttt{curlftpfs} allows mount FTP as local directory, but FTP is outdated, insecure and not constructed to that usage\ldots
	\end{itemize}
	\begin{bashcode}
    wget http://some.address.cz/internet # Download file(s) from Internet
    wget --help # -r for recursive download (whole web), -k to convert links
    # curl is predecessor of wget, without parameter "-o" it prints remote
    # content to standard output (typically screen)
    curl http://some.server.cz/some/files -o localfilename
    # Copy files (-r for recursive) over SSH from local computer
    # to remote server or vice versa (just flip arguments)
    scp -r localfiles remoteuser@remote.server.cz:/remote/path/
    scp -r remoteuser@remote.server.cz:/remote/files /local/directory/
    # scp behaves like cp, but works over SSH
	\end{bashcode}
	\begin{itemize}
		\item \texttt{rsync} is synchronization tool (commonly used for backups) able to connect to remote server (next slide)
		\item On server side, same files can be accessible (shared) by more methods
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Synchronization with rsync}
	\begin{itemize}
		\item \texttt{rsync} has huge amount of possibilities (see \texttt{man rsync} or \texttt{rsync}~-\texttt{h})
		\item Works locally as well as over network
		\item It transmits only changes --- very efficient
		\item Suitable for local as well as network backup
		\item Network address for rsync is written in same way as for \texttt{scp}
		\item -{-}\texttt{delete} delete in target location files which are not in source location any more
		\item -{-}\texttt{progress} show progress percentage for every file
		\item -{-}\texttt{exclude=*.jpg} skip JPG files
		\item For incremental backups use e.g. \texttt{duplicity}
	\end{itemize}
	\begin{bashcode}
    rsync -arv somedirectory otherplace # All attributes, recursive, verbose
    rsync -arv localdirectory user@remote.server.cz:/remote/directory/
    rsync -arv user@remote.server.cz:/remote/data local/directory/
	\end{bashcode}
\end{frame}

\begin{frame}{SSH keys}{Secure way how to connect to multiple servers with single key and more}
	\begin{itemize}
		\item Secure way how to connect to multiple servers via SSH with single (or no) password using asymmetric encryption
		\item Command \texttt{ssh}-\texttt{keygen} generates pair of keys
		\begin{itemize}
			\item Private key is typically in \texttt{$\sim$/.ssh/id\_*} file(s) (according to cipher)
			\item Public key is typically in \texttt{$\sim$/.ssh/id\_*.pub} file(s) (according to selected cipher) and are copied to target servers
			\item Private key is unlocked by password and it then allows to login to any server having the public key
			\item Having only public key is not enough to login, private key without password is still not enough, but user must be sure private key is kept securely and not lost or stolen
		\end{itemize}
		\item File \texttt{$\sim$/.ssh/known\_hosts} contain servers you have ever connect to, and their SSH fingerprints (unique IDs) --- if this changes, SSH complains a lot as it could be \href{https://en.wikipedia.org/wiki/Man-in-the-middle_attack}{Man-in-the-middle attack}
		\item File \texttt{$\sim$/.ssh/authorized\_keys} contains public keys allowing logging to the machine
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Connect to SSH with key}{No need to remember password for every server\ldots}
	\begin{bashcode}
    # Create the key (several options)
    ssh-keygen -t rsa -b 4096 # Good security, portable
    # ECC gives better security, but not all servers/applications support it
    ssh-keygen -t ecdsa -b 521 # Higher security
    ssh-keygen -t ed25519 # Same security as ecdsa, higher performance
    # Empty (no) passphrase will connect to server without password
    # Copy public key to remote server (private key must be kept locally)
    ssh-copy-id user@remote.server.cz # or
    cat ~/.ssh/*.pub | ssh user@remote.server.cz \
      "mkdir -p ~/.ssh && cat >> ~/.ssh/authorized_keys"
    # Now, public key is on the server and private key in local computer is
    # unlocking the connection
    # Unlock the key (no need in some distributions or if there is no
    # passphrase) - must be done only once per user session
    ssh-add
    # Connect as usually
    ssh user@remote.server.cz
	\end{bashcode}
\end{frame}

\begin{frame}[allowframebreaks]{Network tasks}
	\begin{enumerate}
		\item Create SSH key (if you don't have any), copy the public part to \texttt{vyuka.natur.cuni.cz} and connect there with SSH.
		\begin{enumerate}
			\item What are advantages and disadvantages of having the key with or without password?
			\item Is there any reason for having multiple keys? Can you find any examples?
			\item Which services, protocols can use it? Find some examples.
		\end{enumerate}
		\item Make in your notebook new empty directory and mount there via SSHFS your home directory on \texttt{vyuka.natur.cuni.cz} (or on some other server).
		\begin{enumerate}
			\item Explore it. What is then path to files on the remote server?
			\item Disconnect the server when done.
		\end{enumerate}
		\item Use \texttt{wget} and \texttt{curl} to download this presentation to your notebook (link at slide~\ref{materials}).
		\begin{itemize}
			\item For \texttt{curl} be aware of setting of output --- what is default behavior?
		\end{itemize}
		\item Use \texttt{scp} to copy directory with toy data and scripts from your home directory on \texttt{vyuka.natur.cuni.cz} into your notebook.
		\item Use \texttt{scp} to copy any file from your notebook into your home directory on \texttt{vyuka.natur.cuni.cz}.
		\item Use \texttt{rsync} to update toy data and scripts in your notebook according to version on \texttt{vyuka.natur.cuni.cz} in \texttt{/home/scripts\_data}.
		\item Use \texttt{rsync} to update directory with toy data files and scripts in your home directory on \texttt{vyuka.natur.cuni.cz} according to version in your notebook.
		\begin{itemize}
			\item For \texttt{rsync} try to use various options, run it several times.
			\item Explore help of \texttt{rsync}. Can you find there some useful parameters?
		\end{itemize}
		\item Get MAC and IP address of your notebook. Why can be such information useful?
		\item Ping some web server. Is it alive and well reachable?
		\item Why can be output of \texttt{traceroute} useful when you have problems with network?
		\item Mount (explore and then unmount) your CESNET ownCloud into your notebook. If unsure, consult \href{https://du.cesnet.cz/en/navody/owncloud/start}{help} (\href{https://du.cesnet.cz/cs/navody/owncloud/start}{česky}).
		\begin{itemize}
			\item It is available for all academics in the Czech Republic, just go to \url{https://owncloud.cesnet.cz} and login with your institutional credentials
			\item Alternatively connect to some other ownCloud/nextCloud/generic webDAV server
		\end{itemize}
		\item What are advantages and disadvantages of mounting of remote servers (SSHFS,~etc.) into local directories?
		\item Connect to \texttt{vyuka.natur.cuni.cz} (or any other server) using \texttt{mc} and copy there and back some files.
		\item Find in graphical interface of your computer how to connect via SSH/SFTP/SCP to transfer files.
	\end{enumerate}
\end{frame}

\begin{frame}{Faculty web server}
	\begin{itemize}
		\item Login requires same credentials as to \href{https://cas.cuni.cz/}{CAS} (login name, no ISIC number)
		\item Faculty information are \href{https://www.natur.cuni.cz/fakulta/cit/web-aplikace/webhosting}{only in Czech}
		\item It is Linux server running Debian
		\item Connect with SSH/SFTP/SCP to \texttt{web.natur.cuni.cz}
		\item Mainly used for webhosting, user's address will have form \texttt{https://web.natur.cuni.cz/$\sim$loginname/}, user can \href{https://helpdesk.natur.cuni.cz/servlet/HelpdeskDynamic?eid=Rozcestnik}{apply} for another URL
		\item Every department also has dedicated space there, it can be used for various web projects, address can be discussed with \href{https://www.natur.cuni.cz/fakulta/cit/lide}{IT department}
		\item Personal web can be placed in \texttt{public\_html} within home folder
		\item Users can \href{https://helpdesk.natur.cuni.cz/servlet/HelpdeskDynamic?eid=Rozcestnik}{apply} for MySQL database or special settings
		\item \href{https://www.natur.cuni.cz/biology/botany/working-information/servers-webs-computers/}{Department of Botany} (and some other departments) have their own web and file servers
	\end{itemize}
\end{frame}

\subsection{Parallelisation}

\begin{frame}{Parallelisation with GNU Parallel}
	\begin{itemize}
		\item \href{https://www.gnu.org/software/parallel/}{GNU Parallel} can distribute task among CPU threads of one computer, or even among different computers in network
		\item It is not effective for short/small tasks
		\item Important operands (for more see \texttt{man parallel})
		\begin{itemize}
			\item \texttt{\{\}} --- input line --- whole line read from input source (typically standard input)
			\item \texttt{\{.\}} --- input line without extension
			\item \texttt{\{/\}} --- base name of input line --- only file name (without path)
			\item \texttt{\{//\}} --- dirname from input line (filename is removed)
			\item \texttt{\{/.\}} --- base name of input line without extension
			\item \texttt{:::} --- use arguments from command line instead of stdin (::: is placed after the command and before the argument)
			\item \texttt{::::} --- read from argument files
			\item -\texttt{j} --- number of jobs --- if not provided, \texttt{parallel} will use all available CPU threads
			\item See examples on next slides
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{GNU Parallel examples I}
	\begin{bashcode}
    # Convert all images from JPG to PNG
    find . -name '*.jpg' -print | parallel --bar convert '{}' '{.}.png'
    # Resize all images ("\" marks that command continue on next line)
    find . -name '*.jpg' -print | parallel convert -resize 500x500 \
      -quality 75 '{}' '{.}-small.jpg' # or
    parallel convert -resize 25% '{}' '{.}-small.jpg' ::: *.jpg
    # Find WORD in huge text file (named "longfile" here) - this works
    # but it is not possible to get line number (file is red in blocks)
    parallel --pipe --block 10M -- grep --color=always WORD < longfile
    # Same as above but add line numbers according to original file
    nl longfile | parallel -k --pipe --block 20M -- grep WORD
    # When needed to get phrase or regular expression (use parameter
    # "-q" for escaping of shell special characters or extra quotes):
    # "--" stops reading parameters for parallel
    nl longfile | parallel -qk --pipe --block 20M -- grep "WORD TEXT" # or
    nl longfile | parallel -k --pipe --block 20M -- grep '"WORD TEXT"'
    # Convert all WAV files into OGG
    parallel -X oggenc ::: *.wav # -X parse as many parameters as possible
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{GNU Parallel examples II}
	\begin{bashcode}
    # Run in parallel commands from command list file (list of commands)
    parallel < command_list.txt # (each command on one line) or
    parallel :::: command_list.txt
    # Add same text to the end of multiple files
    find . '*.txt' -print | parallel 'cat block_to_be_added.txt >> {}'
    # Replace particular text in multiple files with sed and GNU Parallel
    find . '*.txt' -print | parallel 'sed -i "s/XXX/YYY/g" {}'
    # Launch MrBayes for multiple nexus files and create log file (see also
    # next slide) with starting and ending date and time
    find . '*.nexus' -print | parallel 'echo -e "Start: $(date)\n" > {}.log
      && mb {} | tee -a {}.log && echo "End: $(date)" >> {}.log'
	\end{bashcode}
	\begin{block}{Tasks}
		\begin{enumerate}
			\item Resize using \texttt{parallel} photos \texttt{foto\_oxalis\_*.jpg} to 1000x1000~px.
			\item Convert all above JPG files to PNG.
			\item Use several options how to run \texttt{parallel}.
		\end{enumerate}
	\end{block}
\end{frame}

\begin{frame}[fragile]{Recording output of commands}
	\begin{itemize}
		\item Alternative (commonly more convenient) to redirects of outputs to log file (slide~\ref{pipe}) is command \texttt{tee}
		\begin{itemize}
			\item Very useful if redirects would be harder to code
		\end{itemize}
		\item \texttt{tee} can record
		\begin{itemize}
			\item All output of the software (standard as well as error output)
			\item Commands (keys) typed by user --- it can be later reused to rerun the application --- unique feature useful for certain software
		\end{itemize}
	\end{itemize}
	\begin{bashcode}
    # tee (-a for append to existing file) records output of any application
    command | tee record.txt # tee will record whole output of command
    tee record.txt | command # tee will record user input
    # If software reads commands from user, we can reuse record next time:
    command < record.txt # Empty lines are interpreted as Enter key
                         # Each line is used whenever command waits for new
                         # input (instead of typing, 'record.txt' is used)
	\end{bashcode}
\end{frame}

\subsection{Timing}

\begin{frame}[fragile]{Launching of tasks at certain time}
	\begin{itemize}
		\item \texttt{at} can run command at certain time (\texttt{atd} daemon must be running)
		\item Tasks are running in background, outputs are mailed (e.g. to \texttt{/var/spool/mail/\$USER})
	\end{itemize}
	\begin{bashcode}
    # Check status of atd daemon (it must run), start/stop/enable/disable it
    systemctl status/start/stop/enable/disable atd.service
    man at # Check for various possibilities of time settings
    at HH:MM # Run commands at certain time (hour:minutes)
    at> command1 # Add as many commands as you wish (separate by Enter)
    at> # When done, press Ctrl+D to cancel giving commands to at
    # Instead of manual typing of tasks, run script at certain time
    at HH:MM -f somescript.sh # Run somescript.sh at certain time
    at -l # List of scheduled tasks (alias is atq)
    at -r <number> # Cancel scheduled task (according to number from at -l)
    atrm # Alias for previous command
    batch # Commands will be executed when system loads drops below 0.8 or
          # other value specified in configuration or startup of atd
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{Automated launching of tasks}
	\begin{itemize}
		\item \texttt{cron} runs tasks repeatedly (\texttt{cron} daemon must be running)
		\item Scripts for tasks running hourly/daily/weekly/monthly can be copied into respective \texttt{/etc/cron.*/} directories
	\end{itemize}
	\begin{bashcode}
    # Check status of cron daemon (it must run), start/stop/enable/disable
    systemctl status/start/stop/enable/disable cron.service
    crontab -l # List user's cron tasks
    crontab -e # Edit user's cron tasks:
    # Minute, Hour, Day in month, Month, Day in week, Command(absolute path)
    # 0-59    0-23  1-31          1-12   0-6 starting with Sunday (WTF?)
      *       *     *             *      *            /usr/bin/command
      10      22    1             *      *    # 1st day in month, 23:11
      0       */3   *             *      *    # Every 3 hours
      0       11    *             *      0    # Every Sunday, 12:00
      30      3     */2           *      *    # Every second day, 4:31
      */15    *     *             *      0,4  # At Sun and Fri every 15 min
    # Columns are separated by any number of spaces
	\end{bashcode}
\end{frame}

\section{Text}

\begin{frame}{Text}{Various aspects of working with text files}
	\tableofcontents[currentsection, sectionstyle=show/hide, hideothersubsections]
\end{frame}

\begin{frame}{Everything is (text) file}
	\begin{itemize}
		\item As UNIX configuration and outputs (logs,~\ldots) are mostly saved as relatively simple text files, manipulations of any type with text files is one of the most common tasks
		\begin{itemize}
			\item Similar situation is for molecular data --- input/output data use to be text files with simple structure
		\end{itemize}
		\item One of the most powerful features of BASH
		\item Some operations are complicated (e.g. complex manipulations with columns, various calculations) it is necessary to use AWK or Perl (probably the most advanced language working with text)
		\item Text-manipulating tools have very rich implementation of regular expressions (slide~\ref{regexp})
		\item Most of the operations are done in stream --- per line --- everything is very fast and memory efficient
	\end{itemize}
	\begin{block}{Text tasks}
		Try all the commands from this chapter. It is one of key BASH features.
	\end{block}
\end{frame}

\subsection{Reading}

\begin{frame}[fragile]{Read text file}
	\begin{bashcode}
    cat # Read or join (using redirects) files
        # -n adds line numbers, -v prints non-printable characters like EOL
    cat long_text.txt # Print content of text file
    cat textfile1 >> textfile2 # Append textfile1 to the end of textfile2
    nl long_text.txt # Like cat -n, prints textfile with line numbers
    tac textfile # Like cat, but prints lines in reverse order
    more long_text.txt # When textfile is long, prints screen by screen
                       # (space for next screen, q to quit)
    less long_text.txt # Better version of more - you can scroll up and
                       # down by PgUp, PgDown, arrows, searching by / (type
                       # searched string, hit Enter, n for next, twice ESC
                       # to quit), q to quit viewing (also used by man)
    fmt long_text.txt # Basic formatting of text - joining of commented
                      # lines, line breaks to break too long lines, ...
    fmt textfile > formatted_file # Save output of fmt into new file
    wc long_text.txt # lines, words and bytes in text file
                     # wc -l for only lines, -m for characters, -w for words
    mc # It has text viewer (F3) and editor (F4)
	\end{bashcode}
\end{frame}

\subsection{Extractions}

\begin{frame}[fragile]{Get part of text file (by lines)}
	\begin{bashcode}
    head -n N textfile # Print first N lines from textfile
    tail -n N textfile # Print last N lines from textfile
    head -n-N textfile # Print textfile without last N lines
    tail -n+N textfile # Print textfile from Nth line to the end
    # Split text file on selected pattern - creates new files xxXY
    csplit textfile '/pattern/' '{*}' # pattern itself is inside '/___/'
    # Pattern can be regular expression - set it carefully
    # {*} says to repeat operation as many times as possible
    grep -parameters pattern textfile # Write lines containing pattern
    grep user /etc/passwd # Write all lines in passwd containing user
    cat /etc/passwd | grep user # Same as above
    grep -v user /etc/passwd # Write all lines in passwd NOT containing user
    grep -c user /etc/passwd # Get number of lines in passwd containing user
    grep -i USER /etc/passwd # -i for case insensitive
    grep -q ... # quiet - no output (only T/F) - good for testing in scripts
    grep -ls user /etc/* # -l print files with pattern, -s suppress errors
    grep "longer text" textfile # Extract whole phrase
	\end{bashcode}
	\begin{itemize}
		\item Grep supports regular expressions, slide \ref{regexp}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Work with columns}
	\label{cutpaste}
	\begin{itemize}
		\item \texttt{cut} extracts columns, \texttt{paste} joins, \texttt{column} reformates
		\item BASH can not select column according to its name (Perl can do that)
	\end{itemize}
	\begin{bashcode}
    cut column/delimiter+field textfile
    cut -c 1 /etc/group # Get first character
    cut -c 1-5 /etc/group # Get character 1-5
    cut -c 4- /etc/group # Get character 4 and more
    cut -c 2,5,7 /etc/group # Get characters 2, 5 and 7
    cut -d ':' -f 1 /etc/group # Select 1st field separated by ":"
    cut -d ':' -f 2-4 /etc/group # Select fields 2-4 separated by ":"
    cut -f 1,2 cut_awk_test_file.tsv # get columns 1 and 2 separated by TABs
    # Add second file as second column
    paste file1 file2 > outputfile
    # Output will be two columns (from file1 and file2) separated by TAB
    paste -d "|" diff_test_file_1.txt diff_test_file_2.txt # -d for delimiter
    # Swapping columns is not very comfortable...
    paste <(cut -f2 cut_awk_test_file.tsv) <(cut -f1 cut_awk_test_file.tsv)
    ls -l | column -t # Reformate input as table (compare with 'ls -l')
	\end{bashcode}
	\vfill
\end{frame}

\begin{frame}[fragile]{Examples of usage of head, grep and cut with our data}
	\begin{bashcode}
    head long_text.txt # Beginning of the file
    # Extract names of FASTA sequences
    grep "^>" Oxalis_HybSeq_nrDNA_selection_alignment.fasta
    # Extract every FASTA sequence containing "AAAAAA" and name of
    # respective FASTA sequence
    grep -n -B 1 AAAAAA Oxalis_HybSeq_nrDNA_selection_alignment.fasta
    # Get column of pairwise identities of sequences exported as TSV from
    # Geneious - discard header (1st line, print from 2nd line) and extract
    # second column (separated by TAB)
    tail -n+2 cut_awk_test_file.tsv | cut -f 2 | less
    # Number of occurrences of word "Gregor" in file long_text.txt
    grep -o Gregor long_text.txt | wc -l
    ls -1 *.sh | wc -l # How many BASH script are in current directory
    # Extract from FASTA file only sequence (discard sequence names) and
    # save result in seq.txt
    grep -v "^>" Oxalis_HybSeq_nrDNA_selection_alignment.fasta > seq.txt
    # Save names of oxalis* JPG files into list_oxalis_photo.txt and see it
    ls -1 *oxalis*.jpg > list_oxalis_photo.txt && cat list_oxalis_photo.txt
	\end{bashcode}
\end{frame}

\subsection{AWK}

\begin{frame}[fragile]{Get a~column with awk}
	\begin{itemize}
		\item AWK is scripting language mainly for text manipulations
		\item Can not select column according to its name (Perl can do that)
		\item Can do things other BASH tools can not (easily) do --- better manipulation with columns, calculations,~\ldots
		\item Has complicated syntax, it is hard to read, it is not similar to other tools --- Perl can do more and is more common (learn it instead)\ldots
		\item Supports regular expressions, slide \ref{regexp}
		\item For more information see manuals \url{https://www.gnu.org/software/gawk/manual/}, \url{https://en.wikibooks.org/wiki/An_Awk_Primer} and \url{http://www.grymoire.com/Unix/Awk.html}
	\end{itemize}
	\begin{bashcode}
    awk 'regexp { commands parameters }' file # General syntax
    # Print last column (separated by tab, built-in variable $NF)
    awk '{print $NF}' cut_awk_test_file.tsv
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{AWK examples I}
	\begin{bashcode}
    # Select 2nd column ($2; separated by tab)
    awk '{print $2}' cut_awk_test_file.tsv
    # Print columns 3 and 2 (in this order)
    awk '{print $3, $2}' cut_awk_test_file.tsv
    # Get column 5 and 1 (in this order, separated by ":") from /etc/passwd,
    # print ", username:" between the columns. Note usage of commas and
    # consequences to output.
    cat /etc/passwd | awk -F ':' '{print $5 ", username:", $1}'
    # Separate columns by TAB, /^d/ for lines starting with "d" (only dirs)
    ls -l | awk '/^d/ { print $8 "\t" $3 }'
    # Print on even lines ">", former column 1, new line, former column 2
    # 2 columns into 2 lines (create FASTA from tabular record)
    awk '{print ">"$1"\n"$2}' awk_test_file.tab | less -S
    # Print field 1, TAB (\t), length of field 2, TAB and field 2
    awk '{print $1"\t"length($2)"\t"$2}' awk_test_file.tab
    # If field (column) 2 contains exactly 100.0%, print whole line ($0)
    awk '{if($2=="100.0%"){print $0}}' cut_awk_test_file.tsv
    # Field 1 is numeric (less then 5 digits) - add leading zeroes
    awk '{printf "%05d\n", $1;}' awk_test_file.tab
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{AWK examples II}
	\begin{bashcode}
    # As previous, but add leading zeroes to field 1 and print whole line
    awk '{$1=sprintf("%05d", $1); print $0}' awk_test_file.tab
    # Field 6 is numeric, select lines where field 6 is higher than 200
    awk -F '\t' '$6>200' cut_awk_test_file.tsv # Separated by TABs (\t)
    # Print fields 4 and 5 (fields are separated by "_" or TAB)
    awk -F '[_\t]' '{print $4, $5}' cut_awk_test_file.tsv
    # Precede each line by its line number for all files together, with TAB
    # (i.e. print line number (NR) and then whole original line ($0))
    awk '{print NR "\t" $0}' diff_test_file_*
    # substitute "a" with "XXX" ONLY for lines which contain "The"
    awk '/The/{gsub(/a/, "XXX")}; 1' diff_test_file_1.txt
    # For every 4th line starting from line 2 of FASTQ file (from line 2
    # every 4th line contains the DNA sequence) print its length (bzcat
    # prints content of file compressed by bzip2)
    bzcat Oxalis_hirta_R1.fastq.bz2 | awk 'NR%4==2{ print length($0) }'
    # If sequence is longer that 500 bp (length of field 2), print its name
    # (field 1) like this "Seq. name: TAB the sequence name (ID)"
    awk '{if(length($2)>500){print "Seq. name:\t" $1}}' awk_test_file.tab
	\end{bashcode}
\end{frame}

\subsection{Manipulations}

\begin{frame}[fragile]{Sorting}
	\begin{bashcode}
    sort file # Sorting is influenced by locale setting (e.g. Czech "ch")
    LC_ALL=C sort ... # To force use of English locale use
    sort -d textfile # Take into account only spaces and alphanumerical
                     # characters (ignore any other)
    sort -r textfile # Reverse order
    sort -f textfile # Ignore character case (not case sensitive)
    sort -m textfile1 textfile2 # Merge already sorted text files
    sort -u textfile # Print only first of multiple (repeated) entries
    # Extract only unique sequences from FASTQ
    bzcat Oxalis_hirta_R1.fastq.bz2 | awk 'NR%4==2{print $0}' | sort -u
    sort -b textfile # Ignore leading blanks (space on beginning of line)
    sort -k 2 -n cut_awk_test_file.tsv # Sort according to 2nd field
    uniq textfile # Filters following identical lines - only unique are
                  # printed (to get unique lines from whole file, sort it)
    uniq -c textfile # Add number of occurrences before each line
    uniq -d textfile # Print only repeated lines
    uniq -i textfile # Ignore case (not case sensitive)
    uniq -s N textfile # Skip first N characters
    uniq -u textfile # Print only not-repeated lines
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{Replacements --- tr}
	\begin{itemize}
		\item \texttt{tr} replaces or deletes characters from standard input and writes result to standard output --- use pipes and/or redirects
	\end{itemize}
	\begin{bashcode}
    # Replace space by TAB in inputtextfile, save result as outputtextfile
    cat inputtextfile | tr " " "\t" > outputtextfile
    # Delete "text" from each line and print it to standard output (screen)
    cat inputtextfile | tr -d "text"
    # Replace every occurrence of A, B, C or D by a new line (\n)
    cat inputtextfile | tr "[ABCD]" "\n" > outputtextfile
    # Replace capital letters by small ones
    tr "[A-Z]" "[a-z]" < diff_test_file_1.txt > outputtextfile.txt
    # Alternative (easier reading) of previous command:
    cat diff_test_file_1.txt | tr "[:upper:]" "[:lower:]" > outputtextfile
    # Replace all new lines (line breaks) by TABs
    cat diff_test_file_1 | tr "\n" "\t"  > outputtextfile
    # Discard all new lines - output will be one line
    tr -d "\n" < textfile > /dev/stdout # stdout is typically screen
    tr --help # See another possibilities for pattern to find/replace
	\end{bashcode}
\end{frame}

\begin{frame}{Replacements with sed}
	\begin{itemize}
		\item \texttt{sed} supports regular expressions, see slide \ref{regexp} (same as in \texttt{grep} and \texttt{vim}), with parameter -\texttt{r} can use extended regular expressions (do not confuse --- the syntax is slightly different, richer)
		\item Output is written to standard output --- use pipes, redirects or -\texttt{i} to modify the file in place (without printing of output)
		\item macOS has old outdated versions of \texttt{grep}, \texttt{sed} and other tools (richness of regular expressions is poor) --- use versions from \href{http://brew.sh/}{Homebrew} (slide~\ref{homebrew}) or search Internet how to modify the patterns\ldots
		\item Option -\texttt{s} separates multiple files (otherwise lines in multiple files are calculated as one stream)
		\item Option -\texttt{n} use to be used when deleting lines or printing only specific lines to suppress other lines (see examples)
		\item See manuals \url{https://www.gnu.org/software/sed/manual/} and \url{http://www.grymoire.com/Unix/sed.html}
		\item Various parameters, modificators, operators can be combined\ldots
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Sed examples I}
	\label{sedex}
	\begin{bashcode}
    sed 'operator/FindToReplace/Replace/modificator' textfile > newtextfile
    # Search and replace ("s") all occurrences ("g") of "find" by "replace"
    sed 's/find/replace/g' textfile
    # Replace third occurrence of pattern on every line
    sed 's/pattern/Replace/3' # 's/.../.../' replace only third occurrence
    sed '1,7s/...' # To work only on particular line, place single number or
    sed '5s/...'   # range (e.g. 1,7) right before "s" ("$" for last line)
    sed '1~2n;s/F/R/g' # Work on every second line, starting by line 1
    sed -n '2~10p' # Print every 10th line, starting with line 2
    seq 1 100 | sed -n '2~10p' # Example of above pattern (see "seq 1 100")
    # Replace first TAB (\t) on each line by new line (\n)
    sed 's/\t/\n/' textfile
    # Convert sequences in tabular format into FASTA (place ">" to the
    # beginning of the line, replace TAB "\t" by newline "\n")
    sed 's/^/>/' awk_test_file.tab | sed 's/\t/\n/' > seq.fasta
    # Convert FASTQ sequences into FASTA (on every 4th line, starting with
    # line 1 replace "@" by ">", print every 4th line, starting by line 2)
    bzcat Oxalis_hirta_R1.fastq.bz2 | sed -n '1~4s/^@/>/p;2~4p' > seq.fasta
    sed 's/find/replace/g' somedirectory/* # Work on all files in directory
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{Sed examples II}
	\begin{bashcode}
    # Convert all capital letters into lower
    sed 's/[A-Z]/\L&/g' inputtextfile > outputtextfile # And vice versa:
    sed 's/[a-z]/\U&/g' inputtextfile > outputtextfile
    # Groups to remember work in same way in sed, grep as well as vim
    \(ToRemember\) # Remember expression in brackets
    \Number # Use remembered expression (numbered from one: \1, \2, \3, ...)
    # Take output of ls -l and replace value of $USER by "$USER-RULEZZZ"
    ls -l | sed "s/\($USER\)/\1-RULEZZZ/g" # Note " to use the variable
    # Replace size column (2nd numeric) by "size:TAB<file size>b"
    # Second sed replaces any white spaces by single TAB
    ls -l | sed 's/\([0-9]\+\)/size:\t\1b/2' | sed 's/[[:blank:]]\+/\t/g'
    head long_text.txt | sed '/^$/d' # Delete blank (empty) lines
    head long_text.txt | sed '6d' # Delete 6th line
    sed 's/ *$//' # Delete extra spaces on the end of lines
    sed '/GUI/d' # Delete all whole lines containing "GUI"
    sed 's/GUI//g' # Delete all occurrences of "GUI" (not whole lines)
    sed '4 i\Linux is great.' diff_test_file_1.txt # Insert to 4th line
    sed '3 a\Linux is great.' diff_test_file_1.txt # Insert after 3rd line
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{Sed examples III}
	\begin{bashcode}
    # Insert text to the beginning of the 3rd line (compare with previous)
    # "^" is beginning of line, $ end ('$/...' last line)
    sed '3s/^/INSERT/' diff_test_file_1.txt
    # From ls -l keep number of links (1st numeric column after permissions)
    # and then flip user and group and print it as "group:user"
    ls -l | sed 's/ \([[:digit:]]\+\) \([[:alnum:]]\+\) \([[:alnum:]]\+\) /
      \1 \3:\2 /g' # Note separating spaces (previous line ends with space)
    ls -l # Compare to the previous command, explain behavior of sed pattern
    # Escaping - replace dot by comma (dot means any single character)
    sed 's/\./,/g' diff_test_file_1.txt # \ escapes following character
    sed 's/./,/g' diff_test_file_1.txt # Compare with the previous example
    # Replace any of characters within [...] by some pattern
    sed 's/[abcd]/X/g' diff_test_file_1.txt # Compare with reverse case:
    sed 's/[^abcd]/X/g' diff_test_file_1.txt # "[^...]" means anything else
    sed -i ... file.txt # In-place editing - file is edited, no output to
                        # standard output (no need for redirects and pipes)
    ls -l | sed 's/[0-9]\{4,\}/BIG!/' # Replace 4 or more digits by "BIG!"
    sed -E ... ; sed -r ... # Use extended regular expressions (see further)
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{Joining}
	\begin{itemize}
		\item Generally, most of tools work per-line, \texttt{paste} appends columns (slide~\ref{cutpaste})
		\item Join compares every matching lines (by default 1$^{st}$ field) and creates all combinations --- ensure to have sorted input files with unique text
		\begin{itemize}
			\item E.g. if 1$^{st}$ file contains \texttt{A~B} and \texttt{A~C} and 2$^{nd}$ file \texttt{A~D} and \texttt{A~E}, the result will be \texttt{A~B D}, \texttt{A~B E}, \texttt{A~C D} and \texttt{A~C E}
		\end{itemize}
	\end{itemize}
	\begin{bashcode}
    # Add file to the end of another text file
    cat file1 >> file2 # file2 will contain both files, file1 is unchanged
    # Compare two sorted text files and write shared lines
    # (duplicitous lines are shown just once)
    join textfile1 textfile2 > outputfile
    # If used on wrong files, it can create huge file
    seq -f "1 %g" 100 > aaa && less aaa
    seq -f "1 %g" 100 > bbb && less bbb
    join aaa bbb | wc -l
    join --help # See more options...
	\end{bashcode}
	\vfill
\end{frame}

% \subsection{Compressed text} % TODO Compressed text
%
% \begin{frame}{Variants of basic commands for processing of compressed text files}
% 	\begin{itemize}
% 		\item
% 	\end{itemize}
% \end{frame}

\subsection{Comparisons}

\begin{frame}{Comparisons}
	\begin{itemize}
		\item Graphically compare two files by e.g. \href{https://www.kde.org/applications/development/kompare/}{Kompare}, \href{https://sourcegear.com/diffmerge/}{DiffMerge}, \href{https://meldmerge.org/}{Meld},~\ldots
		\item Most common is usage of GNU diffutils (next slide), see manual \url{https://www.gnu.org/software/diffutils/manual/}
		\item See also \href{https://www.computerhope.com/unix/udiff.htm}{guide with examples}, česky \href{https://blog.root.cz/petrkrcmar/diff-jak-cist-vystup-z-porovnani-souboru/}{příklady na diff} a~\href{https://www.root.cz/clanky/nastroje-pro-porovnani-obsahu-dvou-textovych-souboru/}{porovnání dvou textových souborů}
	\end{itemize}
	\begin{center}
		\includegraphics[height=4.5cm]{kompare.png}
	\end{center}
\end{frame}

\begin{frame}[fragile]{comm and diff}
	\begin{bashcode}
    cat diff_test_file_1.txt diff_test_file_2.txt # See and use examples
    # Compare two sorted columns
    comm textfile1 textfile2
      # 1st column - lines only in textfile1
      # 2nd column - lines only in textfile2
      # 3rd column - lines in both files
    # Don't show 2nd column (similarly -1, -3)
    comm -2 diff_test_file_1.txt diff_test_file_2.txt
    # Show differences between text files
    diff diff_test_file_1.txt diff_test_file_2.txt
      # First number shows line(s) in 1st file, then if add/delete/change
      # and last number shows line(s) in the second file, <> show direction
    diff -e diff_test_file_1.txt diff_test_file_2.txt # More simple output
    diff -c diff_test_file_1.txt diff_test_file_2.txt # Show context
    diff -u diff_test_file_1.txt diff_test_file_2.txt # Better, most common
    diff -y diff_test_file_1.txt diff_test_file_2.txt # In two columns
    colordiff # Same usage and parameters as previous, colored output
    diff -u diff_test_file_1.txt diff_test_file_2.txt | view - # In vim
    vimdiff # Can show more colors, launches vim (exit by <ESC>:q! Enter)
	\end{bashcode}
\end{frame}

% \begin{frame}{Patch} % TODO Add usage of patch
% 	\begin{itemize}
% 		\item
% 	\end{itemize}
% \end{frame}

\subsection{Editors}

\begin{frame}[fragile]{Command line text editors}
	\begin{itemize}
		\item \texttt{nano}, \texttt{pico} and \texttt{mc} are very simple, just for very basic text editing in command line or until you learn \texttt{vim} (graphical version is \textbf{gVim}) or \texttt{emacs} (graphical version is also available, just search for \textbf{Emacs} in your distribution software manager)
		\item You can work most of the time in graphical editors (slide \ref{editors})
		\item Emacs and Vim are extremely rich, but having completely different approach --- when you get use to one, you can't use the another
	\end{itemize}
	\begin{bashcode}
    nano textfile # Enhanced clone of pico, basic simple text editor
    pico textfile # Basic simple text editor
    mc # Use its internal editor, just very basic (press F4 on the file)
    emacs textfile # Extremely feature rich (including file browser
                   # and many tools), Exit by Ctrl+X and Ctrl+C
    vim textfile # Probably the most common, as rich as Emacs (see further)
    vimtutor # Launch tutorial to learn Vim (in various languages)
	\end{bashcode}
	\begin{itemize}
		\item \alert{Task:} Run \texttt{vimtutor} and follow instructions there.
	\end{itemize}
\end{frame}

\begin{frame}{The editors and their usage}
	\begin{itemize}
		\item In \texttt{nano} and \texttt{pico} see bottom line for commands
		\begin{itemize}
			\item \texttt{Ctrl+O} to write the file, \texttt{Ctrl+X} to quit the editor, \texttt{Ctrl+G} for help (\texttt{\textasciicircum}~stands for \texttt{Ctrl} key)
		\end{itemize}
		\item In \texttt{mc} highlight the file to edit and press \texttt{F4}
		\begin{itemize}
			\item \texttt{F2} to save, \texttt{F10} to quit, \texttt{F1} to help, \texttt{F9} for top menu (navigate with arrows, cancel with double \texttt{Esc}), it is possible to use mouse
		\end{itemize}
		\item \textbf{Emacs} use huge number of commands with \texttt{Ctrl} key
		\begin{itemize}
			\item See \url{https://www.gnu.org/software/emacs/tour/}, \url{https://tuhdo.github.io/emacs-tutor.html} and \url{http://www.jesshamrick.com/2012/09/10/absolute-beginners-guide-to-emacs/}
		\end{itemize}
		\item The most common is \textbf{Vim}
		\begin{itemize}
			\item See \url{https://vim-adventures.com/} to play a~game and learn Vim
		\end{itemize}
		\item \textbf{Emacs} and \textbf{Vim} have huge number of possibilities and support for plugins and scripts, but completely different usage style --- one person can really learn only one\ldots
	\end{itemize}
\end{frame}

\begin{frame}{Emacs basics}
	\begin{itemize}
		\item Feature-rich ecosystem --- not only text editor, also file manager, debugger, integrated development environment, extra plugins are available,~\ldots
		\item Keyboard commands are noted as e.g. \texttt{C}-\texttt{x}, where \enquote{\texttt{C}} stands for (mostly) \texttt{Ctrl} key, \texttt{M}-\texttt{x}, where \enquote{\texttt{M}} stands mostly for \texttt{Alt} key (\texttt{Meta}), sometimes for \texttt{Win} key
	\end{itemize}
	\begin{multicols}{2}
		\begin{itemize}
			\item \texttt{C}-\texttt{h C}-\texttt{}h help (twice \texttt{Ctrl~+~H})
			\item \texttt{C}-\texttt{x C}-\texttt{c} quit (\texttt{X}-\texttt{g} for particular buffer, etc.)
			\item \texttt{C}-\texttt{x C}-\texttt{f} open file
			\item \texttt{C}-\texttt{x C}-\texttt{s} save file
			\item \texttt{C}-\texttt{x C}-\texttt{w} save file as
			\item \texttt{C}-\texttt{\_} undo
			\item \texttt{C}-\texttt{s} search forwards
			\item \texttt{C}-\texttt{r} search backwards
			\item \texttt{C}-\texttt{left} move one word left
			\item \texttt{C}-\texttt{right} move one word right
			\item \texttt{C}-\texttt{up} move one paragraph up
			\item \texttt{C}-\texttt{down} move one paragraph down
			\item \texttt{M}-\texttt{\%} search and replace pattern
		\end{itemize}
	\end{multicols}
\end{frame}

\begin{frame}{Vim}{Vim has three different working modes} % TODO Update Vim usage
	\begin{enumerate}
		\item \textbf{\enquote{Normal}} --- nothing is displayed in bottom left corner, every key has some meaning (next slide)
		\begin{itemize}
			\item \texttt{i} or \texttt{Insert} key to enter \textit{insert mode}, \texttt{:} to enter \textit{command mode}
		\end{itemize}
		\item \textbf{Insert} --- in bottom left corner \enquote{{-}- \texttt{INSERT} -{-}} is displayed, the most familiar mode, normal typing etc., exit to normal mode by \texttt{ESC} key
		\item \textbf{Command} --- in bottom left corner \texttt{:} is displayed, awaits commands, exit to normal mode by \texttt{Backspace} key (delete \enquote{\texttt{:}})
	\end{enumerate}
	\begin{itemize}
		\item See documentation \url{http://vim.wikia.com/}, \url{https://www.vim.org/docs.php}; česky \url{http://www.nti.tul.cz/~satrapa/docs/vim/}
		\item For interactive learning try \url{https://vim-adventures.com/} or command \texttt{vimtutor}
	\end{itemize}
\end{frame}

\begin{frame}{Normal and command Vim modes}
	\begin{multicols}{2}
		\begin{itemize}
			\item \textbf{Normal mode}
			\begin{itemize}
				\item \texttt{dd} cut current line
				\item \texttt{r} replace single character below cursor (type then character to be placed instead of the original one)
				\item \texttt{v} for selection of text
				\item \texttt{y} copy selection
				\item \texttt{x} cut selection (always to clipboard, it can be pasted by \texttt{p})
				\item \texttt{p} paste
				\item \textit{number} to get to line of particular line number
				\item \texttt{u} to undo last change(s)
				\item \texttt{/ToSearch} search \enquote{ToSearch} (once press \texttt{Enter}, \texttt{n} for next occurrence, quit with \texttt{Esc})
			\end{itemize}
			\item \textbf{Command mode}
			\begin{itemize}
				\item \texttt{w} write file
				\item \texttt{q} quit
				\item \texttt{q!} quit and discard changes
				\item \texttt{\%s/...} to search and replace as in \texttt{sed}
				\item \texttt{syntax on/off} turn syntax highlight on/off
			\end{itemize}
		\end{itemize}
	\end{multicols}
\end{frame}

\subsection{Regular expressions}

\begin{frame}{Regular expressions are useful\ldots}
	\begin{multicols}{2}
		\begin{center}
			\includegraphics[height=5.5cm]{regular_expressions.png}
		\end{center}
		\columnbreak
		\begin{itemize}
			\item Find text according to a~pattern
			\item Manipulate the text --- flip, reformat, replace,~\ldots
			\item Syntax is variable among programming languages and applications
			\item There are commonly more solutions for one task
			\item Probably the most advanced is Perl
		\end{itemize}
		\vfill
		\url{https://xkcd.com/208/}
	\end{multicols}
\end{frame}

\begin{frame}[allowframebreaks]{Regular expressions}
	\label{regexp}
	\begin{itemize}
		\item \alert{\texttt{.}} --- any single character
		\item \alert{\texttt{*}} --- any number of characters/occurrences of pattern (including 0)
		\item \alert{\texttt{+}} --- one or more occurrences of the preceding reg exp
		\item \alert{\texttt{?}} --- zero or one occurrences of the preceding reg exp
		\item \alert{\texttt{[\ldots]}} --- any character in the brackets
		\item \alert{\texttt{[\textasciicircum\ldots]}} --- reverse case --- all characters except newline and those listed in brackets
		\item \alert{\texttt{\textasciicircum}} --- first character of reg exp --- beginning of the line
		\item \alert{\texttt{\$}} --- last character of reg exp --- end of the line
		\item \alert{\texttt{\textbackslash\{n,m\textbackslash\}}} --- range of occurrences of single character
		\item \alert{\texttt{\textbackslash\{n\textbackslash\}}} --- exactly \textit{n} occurrences
		\item \alert{\texttt{\textbackslash\{n,\textbackslash\}}} --- at least \textit{n} occurrences
		\item \alert{\texttt{\textbackslash}} --- escape following special character (e.g. \texttt{\textbackslash .} to literally search for dot and not \enquote{any single character})
		\item \alert{\texttt{|}} --- either the preceding or following reg exp can be matched (alternation)
		\item \alert{\texttt{\textbackslash(\ldots\textbackslash)}} --- group reg exp (numbered, starting with 1) --- can be called by \alert{\textbackslash\textit{n}}, where \textit{n} is number of the group (starting with 1)
		\item \alert{\texttt{\textbackslash$<$}}, \alert{\texttt{\textbackslash$>$}} --- word boundaries
		\item \alert{\texttt{[[:alnum:]]}} --- alphanumerical characters (includes white space), same like \alert{\texttt{[a}-\texttt{zA}-\texttt{Z0}-\texttt{9]}}
		\item \alert{\texttt{[[:alpha:]]}} --- alphabetic characters, like \alert{\texttt{[a}-\texttt{zA}-\texttt{Z]}}
		\item \alert{\texttt{[[:blank:]]}} --- space and TAB
		\item \alert{\texttt{[[:cntrl:]]}} --- control characters
		\item \alert{\texttt{[[:digit:]]}} --- numeric characters, like \alert{\texttt{[0}-\texttt{9]}}
		\item \alert{\texttt{[[:graph:]]}} --- printable and visible (non-space) characters
		\item \alert{\texttt{[[:lower:]]}} --- lowercase characters, like \alert{\texttt{[a}-\texttt{z]}}
		\item \alert{\texttt{[[:print:]]}} --- printable characters (includes white space)
		\item \alert{\texttt{[[:punct:]]}} --- punctuation characters
		\item \alert{\texttt{[[:space:]]}} --- white space characters
		\item \alert{\texttt{[[:upper:]]}} --- uppercase characters, like \alert{\texttt{[A}-\texttt{Z]}}
		\item \alert{\texttt{[[:xdigit:]]}} --- hexadecimal digits
		\item \alert{\texttt{\textasciicircum\$}} --- blank line
		\item \alert{\texttt{\textasciicircum.*\$}} --- entire line whatever it is
		\item \alert{\texttt{ +}} --- one or more spaces (there is space before plus)
		\item \alert{\texttt{\&}} --- content of pattern that was matched
		\item Implementation in \texttt{vim}, \texttt{sed}, \texttt{grep}, \texttt{awk} and \texttt{perl} and among various UNIX systems is almost same, but not identical\ldots
		\item \textbf{grep}, \textbf{sed} and \textbf{vim} \alert{require escaping} of \alert{\texttt{+}}, \alert{\texttt{?}}, \alert{\texttt{\{}}, \alert{\texttt{\}}}, \alert{\texttt{(}} and \alert{\texttt{)}} by backslash \alert{\texttt{\textbackslash}} (e.g. \texttt{\textbackslash +}) --- \textbf{egrep} (extended version, launched as \texttt{grep}~-\texttt{E \ldots} or \texttt{egrep \ldots}), \textbf{sed} with extended reg exp (\texttt{sed}~-\texttt{r}) and \textbf{perl} \alert{not}
		\item Read \url{https://en.wikibooks.org/wiki/Regular_Expressions}, \url{http://www.grymoire.com/Unix/Regular.html}, \url{https://www.regular-expressions.info/}; česky \url{http://www.nti.tul.cz/~satrapa/docs/regvyr/}, \url{https://www.root.cz/serialy/regularni-vyrazy/} a~\url{https://www.regularnivyrazy.info/}
		\item Manuals for \href{https://www.gnu.org/software/grep/manual/}{Grep}, Vim, \href{https://www.gnu.org/software/sed/manual/}{Sed}, \href{https://www.gnu.org/software/gawk/manual/}{Awk}, \href{https://en.wikibooks.org/wiki/Perl_Programming}{Perl} (\href{https://en.wikibooks.org/wiki/Perl_6_Programming}{newer Perl~6}),~\ldots
		\item See sed examples, slide~\ref{sedex}; and next slide
		\item macOS has by default very outdated version of \texttt{sed} and another tools --- it does not have all advanced features --- users need to install e.g. \texttt{gnu}-\texttt{sed} formulae from \href{https://brew.sh/}{Homebrew} (slide~\ref{homebrew})
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Grep and sed examples}
	\begin{bashcode}
    # Extract sequences with at least 5 A bases in line
    grep "A\{5,\}" Oxalis_HybSeq_nrDNA_selection_alignment.fasta
    # Extract DNA sequence string ATCG or ATGC
    grep "ATCG\|ATGC" Oxalis_HybSeq_nrDNA_selection_alignment.fasta
    # Get quality of Illumina reads mapping to reference in genomic VCF
    zcat arabidopsis.vcf.gz | grep -o "MQ=[[:digit:]]\+"
    # How many times there is a direct speech (text between "...")
    grep -o '\"[[:upper:]][a-zA-Z0-9,\.\?\! ]\+\"' long_text.txt | wc -l
    # Add after dot on the end of the line by extra line break
    sed 's/\.$/.\n/' long_text.txt
    # Add HTML paragraph tags (<p> and </p>)
    sed -e 's/^/<p>/' -e 's/$/<\/p>/' long_text.txt | less
    # Make first word of every paragraph bold in HTML (<strong>...</strong>)
    sed -e 's/^/<strong>/' -e 's/^[[:graph:]]\+/&<\/strong>/' long_text.txt
    # How many times is each word in the text
    grep -o "\<[[:alpha:]]\+\>" long_text.txt | sort | uniq -ic | less
    # List all Internet web links
    grep -o "http[a-zA-Z0-9\.()/:\-]\+" long_text.txt
	\end{bashcode}
\end{frame}

% \subsection{} % TODO Add text tasks
%
% \begin{frame}{Text tasks}
% 	\begin{enumerate}
% 		\item
% 	\end{enumerate}
% \end{frame}

\section{Scripting}

\begin{frame}{Scripting}{Basics of writing scripts in BASH}
	\tableofcontents[currentsection, sectionstyle=show/hide, hideothersubsections]
\end{frame}

\subsection{Basic skeleton}

\begin{frame}[fragile]{Basic script}
	\begin{itemize}
		\item Every script begins with \texttt{\#!/bin/bash} (or alternative for another shells, Perl,~\ldots)
		\item Add any commands you like\ldots
		\item Every script should end with \texttt{exit} (but it is not necessary)
		\item After writing the script, add execution permission (\texttt{chmod +x noninteractive.sh})
		\item Launch with \texttt{./noninteractive.sh}
		\item The most simple script:
	\end{itemize}
	\begin{bashcode}
    #!/bin/bash
    # Simple non-interactive script - no communication with user
    # only list of commands - prints user name, date and $PATH
    echo "Hi, $USER, today is $(date) and your PATH is $PATH."
    echo
    exit
	\end{bashcode}
\end{frame}

\subsection{BASH variables}

\begin{frame}{Special variables available in the script (selection)}
	\begin{itemize}
		\item \alert{\texttt{\$1}},~\ldots~(number from \texttt{1} up to number of parameters) --- individual positional parameters (see further for example)
		\item \alert{\texttt{\$0}} --- path of the starting script
		\item \alert{\texttt{\$\#}} --- number of command-line arguments
		\item \alert{\texttt{\$*}} --- all of the positional parameters, seen as a~single word, must be quoted (i.e. \texttt{"\$*"})
		\item \alert{\texttt{\$@}} --- same as \texttt{\$*}, but each parameter is a~quoted string --- the parameters are passed on intact, without interpretation or expansion, each parameter in the argument list is seen as a~separate word, should be quoted (i.e. something like \texttt{"\$@"})
		\item \alert{\texttt{\$\$}} --- process ID (PID) of the script itself
		\item \alert{\texttt{\$?}} --- Exit status of previous command, function, or the script itself
		\item \href{https://www.tldp.org/LDP/abs/html/internalvariables.html}{See more variables\ldots}
	\end{itemize}
\end{frame}

\subsection{Functions}

\begin{frame}[fragile]{Functions in BASH}{Pieces of code, which can be used repeatedly}
	\begin{bashcode}
    # Declare new function
    function MyNewFunction1 {
      echo "Hello, $USER from $(groups) on $HOSTNAME!"
      }
    # Use it in a script as any other command
    ...
    MyNewFunction1
    ...
    # Use with variables - provide parameters for the function
    # See following script examples for another input - same as in scripts
    function MyNewFunction2 {
      echo "The sum is $(("$1" + "$2"))."
      }
    # Use it in the script
    ...
    MyNewFunction2 5 8 # For example
    ...
	\end{bashcode}
\end{frame}

\subsection{Reading variables}

\begin{frame}{It is important to check user input\ldots}
	\begin{center}
		\includegraphics[width=7.5cm]{exploits_of_a_mom.png}
	\end{center}
	\begin{flushright}
		\url{https://xkcd.com/327/}
	\end{flushright}
	\begin{itemize}
		\item By accident or purpose (attack), user can enter unexpected value
		\begin{itemize}
			\item In the \enquote{best} case, the script \enquote{just} crashes
			\item Script can behave unexpectedly, returning very weird results
			\item Internal functions/commands can return error messages, which are hard to understand
			\item Attacker can e.g. modify web content (\href{https://en.wikipedia.org/wiki/Cross-site_scripting}{XSS},~\ldots), obtain private data, root privileges,~\ldots
		\end{itemize}
		\item Programmer should always check if user input is correct, filter it
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Script reading two variables}
	\begin{bashcode}
    #!/bin/bash
    # Arguments are read from command line as parameters of the script
    # Order has to be kept (well, not in this case, but generally yes)
    echo "Sum of two numbers $1 and $2 is $(("$1" + "$2"))." # $((calc...))
    # "$#" is available every time and contains number of parameters
    # (variables) given to the script
    echo "Number of parameters is: $#"
    # "$*" is available every time and contains all supplied parameters
    echo "Those parameters were supplied: $*"
    #  "$0" is available every time and contains script path
    echo "Path to the scrip is: \"$0\""
    echo
    exit
	\end{bashcode}
	\vfill
	When done, do:
	\vfill
	\begin{bashcode}
    chmod +x interactive1.sh
    ./interactive1.sh 8 9 # Or select any other two numbers
	\end{bashcode}
	\vfill
	\begin{itemize}
		\item There is no checking of input values, nothing advanced,~\ldots
	\end{itemize}
	\vfill
\end{frame}

\begin{frame}[fragile]{Variables will be interactively provided by the user}
	\begin{bashcode}
    #!/bin/bash
    # Arguments are read from user input (script asks for them)
    echo "Please, input first value to sum and press 'Enter'"
    read -r V1
    echo "Please, input second value to sum and press 'Enter'"
    read -r V2
    echo "Sum of two numbers $V1 and $V2 is $(("V1" + "V2"))."
    # $ is unnecessary on arithmetic variables
    echo
    exit
	\end{bashcode}
	\vfill
	When done, do:
	\vfill
	\begin{bashcode}
    chmod +x interactive2.sh
    ./interactive2.sh # Values will be provided when script asks
	\end{bashcode}
	\begin{itemize}
		\item There is no checking of input values, nothing advanced,~\ldots
		\item See next slide to read the variable in \texttt{while} cycles to ensure it is correctly entered
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Ensuring user interactively provides correct input (while)}
	\begin{itemize}
		\item Detailed explanations of all features used here are in various following slides\ldots{ }See scripts \texttt{interactive2\{whiles,functions\}.sh}
	\end{itemize}
	\begin{bashcode}
    ... # Following code replace lines 3 and 4 from previous script
    NUMBER='^[0-9]+$'
    echo "Please, provide a number as input value:"
    while : # Start of while cycles - run until correct input is provided
      do # Star of the body of the cycles
      read -r INPUT # Here the input from keyboard is received
      if [[ $INPUT =~ $NUMBER ]]; then # Test if INPUT is a number
        echo "OK, input value is $INPUT."
        break # We have correct value, we can break the cycles and continue
        else # What to do if the user did not provided correct value
          echo "Error! You provided wrong value!" # Tell the user
          echo "Try again (the number):" # Ask user for new input value
        fi # End of the conditional evaluation
      done # End of the while cycles
    ... # The code continues... Such check is needed for every variable...
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{Ensuring user interactively provides correct input (function)}
	\begin{bashcode}
    # Regular expression to check if the provided input is a~number
    NUMBER='^[0-9]+$' # From beginning (^) to end ($) only numbers
    # Function to read and check user input (this goes to beginning)
    function checkinput {
      while :
        do # Star of the body of the cycles
          read -r INPUT # Here the input from keyboard is received
          if [[ $INPUT =~ $NUMBER ]]; then # Test if $INPUT is a number
            echo "OK, input value is $INPUT."
            break # We have correct value, we can break and continue
            else # What to do if the user did not provide correct value
              echo "Error! You provided wrong value!" # Tell the user
              echo "Try again (the number):" # Ask user for new input value
             fi # End of the conditional evaluation
        done # End of the while cycles
      } # Read variable is in $INPUT
    # Replace line 4 of interactive2.sh by (similarly for line 6)
    checkinput
    V1=$INPUT
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{Provide named parameters}
	\begin{bashcode}
    #!/bin/bash
    # Script has only one parameter ($1) provided
    # "case" is evaluating provided parameter and behaving accordingly
    case "$1" in
      d|disk) # "|" means alternatives - more possible inputs
        echo "Your disk usage is:"
        df -h;;
      u|uptime)
        echo "Your computer is running:"
        uptime;;
      # This should be every time last possibility - any other input
      # User is then notified he entered nonsense and gets some help
      *) # Any other input
        echo "Wrong option!"
        echo "Usage: 'd' or 'disk' for available disk space or 'u' or"
        echo "  'uptime' for computer uptime"
        exit 1;; # In this case, exit with error code 1
      esac
    exit
	\end{bashcode}
\end{frame}

\begin{frame}{Notes to previous script}
	\begin{itemize}
		\item First make \texttt{interactive3.sh} executable and launch it via e.g. \texttt{./interactive3.sh d} or \texttt{./interactive3.sh uptime} or so
		\item Function \texttt{case} has basic checking of input available --- as last parameter use \texttt{*)} --- any other input except those defined above will produce some warning message, error or so
		\item In same way can be added more parameters (by multiple use of \texttt{case} or by wrapping \texttt{case} by \texttt{while} loop), in the latter variant order of parameters does not have to be kept and all parameters are compulsory
		\item \texttt{case} can evaluate simple regular expressions, e.g. \texttt{[Uu]ptime}, \texttt{d*},~\ldots
		\item This is the most simple usage, more complex possibilities are ahead
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Provide parameters, verify them and behave accordingly I}
	\begin{bashcode}
    #!/bin/bash
    # From the beginning (^) to the end ($) at least one (+) number ([0-9])
    NUMBER='^[0-9]+$'
    function usagehelp { # Function to print help - we will use it twice
      echo "Usage: number1 plus/minus/product/quotient number2"
      echo "Use plus for sum, minus for difference, product"
      echo "  for multiplication or quotient for quotient."
      exit 1 # End up with an error
      }
    if [ "$#" -ne "3" ]; then # Do we have 3 parameters provided?
      echo "Error! Requiring 3 parameters! Received $# ($*)."
      usagehelp # The function to print help
      fi # "=~" means testing if $1 fits to regular expression in $NUMBER
    if [[ ! $1 =~ $NUMBER ]]; then # Is parameter 1 number?
      echo "Parameter 1 is not an integer!"
      usagehelp # The function to print help
      fi
    # Continues on next slide...
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{Provide parameters, verify them and behave accordingly II}
	\begin{bashcode}
    # Remaining part from previous slide...
    if [[ ! $3 =~ $NUMBER ]]; then # Is parameter 3 number?
      echo "Parameter 3 is not an integer!"
      usagehelp # The function to print help
      fi
    case "$2" in
      plus) echo "$(($1 + $3))";;
      minus) echo "$(($1 - $3))";;
      product) echo "$(($1 * $3))";;
      quotient) echo "$(($1 / $3))";;
      *) echo "Wrong option!"
        usagehelp # The function to print help
        ;;
      esac
    exit
	\end{bashcode}
	\vfill
	\hrule
	\vfill
	\begin{bashcode}
    chmod +x interactive4.sh && ./interactive4.sh 7 plus 5 # For example...
	\end{bashcode}
	\vfill
\end{frame}

\begin{frame}[fragile]{Multiple switches in classical UNIX form (no positional) I}
	\begin{itemize}
		\item Following code use to be near beginning of the script to evaluate input
		\item See \texttt{interactive5.sh} for complete example
		\item \texttt{getopts} reads short (one-letter) parameters, they can have input value (marked by \texttt{:})
	\end{itemize}
	\begin{bashcode}
    #!/bin/bash
    # All provided values are evaluated in while cycles...
    while getopts "hvi:o:a:" INITARGS; do
    case "$INITARGS" in # $INITARGS contains the parameters to evaluate
      h|v) # Accept parameters "-h" or "-v" for help
        echo "Usage options..."
        exit # Terminate after providing help
        ;; # End of this option
      i) # Parameter "-i" accepts some value (e.g. "-i inputfile.txt")
        ... # Do some checking etc...
        INPUTFILE="$OPTARG" # $OPTARG always contains value of parameter
        ;; # End of this option
    # ...continues on following slide...
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{Multiple switches in classical UNIX form (no positional) II}
	\begin{bashcode}
    # ...starts on previous slide...
        o) # Parameter "-o" accepts some value (e.g. "-o outputfile.txt")
          ... # Do some checking etc...
          OUTPUTFILE="$OPTARG" # $OPTARG always contains value of parameter
          ;; # End of this option
        a) # Parameter "-a" accepts some value (e.g. "-a X" for number)
          # Check if provided value makes sense (integer between 10 and 300)
          if [[ "$OPTARG" =~ ^[0-9]+$ ]] && [ "$OPTARG" -ge 10 ] &&
            [ "$OPTARG" -le 300 ]; then # The condition is long...
            VALUE=$OPTARG # $OPTARG always contains value of parameter
            echo "Value is OK: $VALUE"
            else
             echo "Error! For parameter \"-a\" you did not provide an"
             echo "  integer ranging from 10 to 300!"
             exit 1
            fi
          ;; # End of this option
    # ...continues on following slide...
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{Multiple switches in classical UNIX form (no positional) III}
	\begin{bashcode}
    # ...continuing from previous slide...
        ?)
          echo "Invalid option(s)!"
          echo "See \"$0 -h\" for usage options."
          exit 1
          ;; # End of this option
        esac
      done # ...the end.
    # Check if all required values are provided
    if [ -z "$INPUTFILE" ] || [ -z "$OUTPUTFILE" ]; then
      echo "Error! Name of input and/or output file was not provided!"
      echo "See \"$0 -h\" for help usage..."
      exit 1
      fi
    if [ -z "$VALUE" ]; then
      echo "Warning! Value for \"-a\" was not provided! Using default (10)."
      VALUE=10
      fi # ...ends on following slide...
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{Multiple switches in classical UNIX form (no positional) IV}
	\begin{bashcode}
    # ...continuing from previous slide...
    # Do the job...
    for I in $(seq 1 $VALUE); do # Repeat task number of times ($VALUE x)
      echo -ne "Cycle $I...\r" # Write number of cycle and return cursor to
           # the beginning of the line to overwrite the number in next step
      sleep 1s # Wait 1 second - just for fun ;-)
      # Do the task - append input to the output - note usage of variables
      cat "$INPUTFILE" >> "$OUTPUTFILE" # Do the task - append inp to output
      done
    echo -ne "\n" # Reset cursor to new line
    echo "Done!"
    exit
	\end{bashcode}
	\vfill
	\begin{itemize}
		\item Script \texttt{interactive5.sh} contains complete example
	\end{itemize}
	\vfill
	\begin{bashcode}
    # Start with displaying help
    ./interactive5.sh -h # Or ./interactive5.sh -v
    # Try it as common command line tool
    ./interactive5.sh -i input.txt -o output.txt -a 50
    ./interactive5.sh -o out.txt -a 50 -i input.txt # Order doesn't matter
	\end{bashcode}
\end{frame}

\subsection{Branching the code}

\begin{frame}[fragile]{If branching (examples are elsewhere)}
	\begin{bashcode}
    # Basic variant - commands are done only if condition is met
    if expression; then
        commands
      fi
    # Two branches - when condition is met and when not
    if expression; then
        commands1 # expression is TRUE
      else
        commands2 # expression is FALSE - all other cases
      fi
    # Join together two (or more) if branches
    if expression1; then
        commands1
      elif expression2; then
          commands2
        else
          commands3
        fi
	\end{bashcode}
\end{frame}

\begin{frame}[allowframebreaks]{Evaluation of conditions}
	\begin{itemize}
		\item \enquote{\texttt{[} \ldots~\texttt{]}} (always keep space around it --- inside) is function to evaluate expressions (alternatively use command \texttt{test})
		\begin{itemize}
			\item \texttt{if [ "\$VAR"} -\texttt{eq 25 ]} or \texttt{test \$VAR} -\texttt{eq 25}
			\item \texttt{if [ "\$VAR" == "value" ]; \ldots}
			\begin{itemize}
				\item Escaping variables and values by double quotes (\texttt{"}\ldots\texttt{"}) is recommended (to be sure), but not strictly required all the time
			\end{itemize}
			\item \texttt{if [ !} -\texttt{f regularfile ]; \ldots} --- reverted condition (\texttt{!})
			\item Single-bracket conditions --- file, string, or arithmetic conditions
			\item Double-bracket syntax --- enhanced
			\begin{itemize}
				\item Allow usage of regular expressions and globing patterns
				\item Word splitting is prevented --- \texttt{\$STRINGVAR} can contain spaces
				\item Expanding file names --- \texttt{if [[} -\texttt{a *.sh ]]} (variant with only one bracket doesn't work when there are multiple sh files)
				\item Allows more detailed test, e.g. \texttt{if [[ \$num} -\texttt{eq 3 \&\& "\$STRINGVAR" == XXX ]]} \ldots
			\end{itemize}
		\end{itemize}
		\item -\texttt{eq} --- Equal to
		\item -\texttt{lt} --- Less than
		\item -\texttt{gt} --- Greater than
		\item -\texttt{ge} --- Greater than or equal to
		\item -\texttt{le} --- Less than or equal to
		\item -\texttt{f \$FILE} --- True if \texttt{\$FILE} exists and is a~regular file
		\item -\texttt{r \$FILE} --- True if \texttt{\$FILE} exists and is readable
		\item -\texttt{w \$FILE} --- True if \texttt{\$FILE} exists and is writable
		\item -\texttt{x \$FILE} --- True if \texttt{\$FILE} exists and is executable
		\item -\texttt{d \$FILE} --- True if \texttt{\$FILE} exists and is a~directory
		\item -\texttt{s \$FILE} --- True if \texttt{\$FILE} exists and has a~size greater than zero
		\item -\texttt{n \$STR} --- True if string \texttt{\$STR} is not a~null (empty) string
		\item -\texttt{z \$STR} --- True if string \texttt{\$STR} is a~null string
		\item \texttt{\$STR1 == \$STR2} --- True if both strings are equal
		\item \texttt{\$STR} --- True if string \texttt{\$STR} is assigned a~value and is not null
		\item \texttt{\$STR1 != \$STR2} --- True if both strings are unequal
		\item -\texttt{a} --- Performs the \texttt{AND} function
		\item -\texttt{o} --- Performs the \texttt{OR} function
		\item Do not confuse globing patterns and regular expressions when using \texttt{[[ \ldots~]]}
		\begin{itemize}
			\item Shell globing: \texttt{if [[ "\$STRINGVAR" == ?[sS]tring* ]]; then} --- \texttt{?} represents single character \texttt{[]} any character inside and \texttt{*} zero or more characters
			\item Regular expressions: \texttt{if [[ "\$STRINGVAR" =$\sim$ .[sS]tring.* ]]; then} --- \texttt{.} represents single character (\texttt{?} would be zero or one occurrence of preceding expression), \texttt{[]} any character inside and \texttt{.*} zero or more occurrences of any single characters
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Selecting version of RAxML according the CPU type I}
	\begin{itemize}
		\item \href{https://github.com/stamatak/standard-RAxML}{RAxML} can take advantage of modern CPUs to highly speed up calculations, with or without parallelisation --- every version has separated binary, user must select, see \href{https://github.com/stamatak/standard-RAxML/blob/master/README}{README}
		\item After compilation, the script can select e.g. on remote server
		\item RAxML binaries must be in \texttt{\$PATH}
		\item See \texttt{raxml\_if.sh} for whole script
	\end{itemize}
	\begin{bashcode}
    if grep -iq avx2 /proc/cpuinfo; then # Does the CPU support AVX2?
      RAXML='raxmlHPC-AVX2' # Select appropriate binary
      elif grep -iq avx /proc/cpuinfo; then # Does the CPU support AVX?
        RAXML='raxmlHPC-AVX' # Select appropriate binary
        elif grep -iq sse3 /proc/cpuinfo; then # Does the CPU support SSE3?
          RAXML='raxmlHPC-SSE3' # Select appropriate binary
          else # The very last option
            RAXML='raxmlHPC' # Slowest oldest CPU...
      fi # End of branching
    "$RAXML" -s "$INPUT" # All the parameters as usually...
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{Selecting version of RAxML according the CPU type II}{Multiple branching in one step}
	\begin{itemize}
		\item Same task as on previous slide, but instead of it-then branching it is using \texttt{case}
		\item See \texttt{raxml\_case.sh} for whole script
	\end{itemize}
	\begin{bashcode}
    # Determine which CPU is available and which binary use then
    CPUFLAGS=$(grep -i flags /proc/cpuinfo | uniq)
    case "$CPUFLAGS" in
      *avx2*|*AVX2*) # Does the CPU support AVX2?
        RAXML='raxmlHPC-AVX2';; # Select appropriate binary
      *avx*|*AVX*) # Does the CPU support AVX?
        RAXML='raxmlHPC-AVX';; # Select appropriate binary
      *sse3*|*SSE3*) # Does the CPU support SSE3?
        RAXML='raxmlHPC-SSE3';; # Select appropriate binary
      *) # The very last option
        RAXML='raxmlHPC';; # Slowest oldest CPU...
      esac # End of branching
    "$RAXML" -s "$INPUT" # All the parameters as usually...
	\end{bashcode}
\end{frame}

\subsection{Loops}

\begin{frame}[fragile]{For cycles}
	\begin{bashcode}
    # Ways how to declare number of repetitions
    for I in $(seq 1 10); do echo $I; done # "seq" is outdated
    for I in 1 2 3 4 5 6 7 8 9 10; do echo $I; done
    for I in {1..10}; do echo $I; done
    for (( I=1; I<=10; I++ )); do echo $I; done
    # One line for cycle for resizing of images (another option, as above)
    for JPGF in *.jpg; do convert $JPGF -resize 100x100 thumbs-$JPGF; done
    # More commands in a block
    for JPGF in $(ls -1 *.jpg); do
      echo "Processing JPGF $JPGF"
      convert $JPGF -resize 100x100 thumbs-$JPGF
      echo "File thumbs-$file created"
      done
    for ...; do # Start cycles as you need
      command1 # command1 will be executed in any case
      if (condition); then # Set some condition to skip command2
        continue; fi # Go to next iteration of the loop and skip command2
      command2
      done
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{While and until cycles}
	\begin{bashcode}
    # while cycle is evaluating expression and if it is equal to 0
    # the cycle body is launched, repeatedly while the condition is met
    while expression
      do
        commands
      done
    # Like while cycle, but until expression is not equal to zero
    until expression; do
      commands
      done
    while ...; do # Start cycles as you need
      commands...
      if [condition]; then # If something happens
        break; fi # End up the cycles and continue by following commands
    while read TEXTLINE; do # Run cycles on text file
      commands...
      done < text_file_to_process.txt
    while :; do echo "Press CTRL+C to exit..."; done # Infinite loop
    for (( ; ; )) ; do echo "Press CTRL+C to exit..."; done # Infinite loop
	\end{bashcode}
\end{frame}

\section{Software}

\begin{frame}{Software}
	\tableofcontents[currentsection, sectionstyle=show/hide, hideothersubsections]
\end{frame}

\subsection{Packages}

\begin{frame}[allowframebreaks]{Package management}{Installation of software}
	\begin{itemize}
		\item \textbf{Package} --- an application or its part (documentation, plug-ins, translations,~\ldots)
		\item Packages are available in \textbf{repositories} (directories) on the internet
		\begin{itemize}
			\item System has list of applications available
			\item Updates and bug fixes are installed for all applications using one interface (GUI or command line) --- very reliable
			\item Packages are digitally signed --- security
			\item User can set custom repositories to get new packages
			\item Repositories can be added whenever needed --- check documentation for your distribution (at least basic \enquote{how-to})
		\end{itemize}
		\item The most different task among distributions
		\item Packages have dependencies --- required shared libraries and so on --- use package manager and try to avoid downloading packages from the internet
		\item \alert{Read manual for your distribution!}
		\item Package is basically an archive and system has configured directories where to unpack it --- binaries are commonly in \texttt{/usr/bin/}, shared libraries in \texttt{/usr/lib} and \texttt{/sr/lib64}, data in \texttt{/var},~\ldots
		\item User should not care where parts of packages go to --- system is taking the care --- user can only damage it
		\item Shared libraries are installed automatically whenever required
		\item As all files are placed in standard defined directories, it is very simple to use them also for another applications
		\item Applications not available in repositories, neither as distributional package should be installed into \texttt{$\sim$/bin} for current user or \texttt{/usr/local} for all users (binaries then go into \texttt{/usr/local/bin} and so on)
		\item Common distributions use to provide convenient graphical tool to manage software
		\begin{itemize}
			\item Ubuntu Software Center
			\item Synaptic --- feature rich, graphical, advances, for any DEB distribution
			\item Aptitude --- feature rich, command-line, advanced, for any DEB distribution (more advanced version of Apt)
			\item DPKG --- low-level, any DEB-based distribution
			\item YaST Software for openSUSE (feature rich, graphical as well as command-line)
			\item Zypper --- feature rich, command-line, advanced, for openSUSE
			\item DNF --- feature rich, command-line, advanced, for Fedora and another RPM based distributions (replacing older Yum)
			\item RPM --- low level, any RPM-based distribution
			\item GNOME software --- in most of distributions using GNOME
			\item And many more\ldots
		\end{itemize}
		\item Distributions use to provide convenient simple update applet notifying about awaiting updates
		\item There use to be web services to look for packages, also from other sources --- \href{https://software.opensuse.org/search}{openSUSE}, \href{https://www.debian.org/distrib/packages\#search_packages}{Debian}, \href{https://packages.ubuntu.com/}{Ubuntu} (+ \href{https://launchpad.net/ubuntu/+search}{Launchpad} and \href{https://launchpad.net/ubuntu/+ppas}{PPAs}), \href{https://apps.fedoraproject.org/packages/}{Fedora},~\ldots
		\item The task is always same, the exact work-flow and commands more or less differ among distributions\ldots
		\item Tools like Android Google Play, Apple Store or Windows Store are inspired from Linux\ldots
		\item \alert{\textbf{Task:} Install some new software into your Linux. Use graphical as well as command-line tools. See following slides for instructions.}
	\end{itemize}
\end{frame}

\begin{frame}[allowframebreaks]{Package management in command line in openSUSE and SLE (basic commands)}
	\begin{itemize}
		\item Root password is required: use \texttt{sudo\ldots} or \texttt{su}~-
		\item Package name \texttt{*.rpm}
		\item \texttt{zypper in \textit{package}} --- install \textit{package}
		\item \texttt{zypper rm \textit{package}} --- remove \textit{package}
		\item \texttt{zypper ref} --- refresh repositories
		\item \texttt{zypper up} --- update
		\item \texttt{zypper dup} -- upgrade to newer release of whole distribution
		\item \texttt{zypper se \textit{term}} --- search \textit{term}
		\item \texttt{rpmorphan} and/or \texttt{zypper} \texttt{pa} -{-}\texttt{orphaned} -{-}\texttt{unneeded} --- list packages, which can be safely removed
		\item \texttt{yast sw\_single} --- interactive manager
		\item \texttt{zypper lr} --- list repositories
		\item \texttt{zypper ar \textit{repository}} --- add \textit{repository} (URL of remote \texttt{*.repo} file)
		\item \texttt{zypper rr \textit{repository}} --- remove \textit{repository} (name according to \texttt{zypper lr})
		\item \texttt{zypper mr \textit{repository}} --- modify \textit{repository} (see \texttt{man zypper} first or use \texttt{yast sw\_single})
		\item \texttt{zypper pa \textit{package}} --- get information about particular \textit{package} or another query (e.g. list of dependencies, see \texttt{man zypper})
		\item \texttt{rpm*} commands for other tasks
		\item \texttt{man zypper}, \texttt{man rpm} --- usage help
	\end{itemize}
\end{frame}

\begin{frame}[allowframebreaks]{Package management in command line in Debian/Ubuntu and derivatives (basic commands)}
	\begin{itemize}
		\item Root password is required: use \texttt{sudo\ldots} or \texttt{su}~-
		\item Package name \texttt{*.deb}
		\item \texttt{apt}-\texttt{get install \textit{package}} --- install \textit{package}
		\item \texttt{apt}-\texttt{get remove \textit{package}} --- remove \textit{package}
		\item \texttt{apt}-\texttt{get update} --- refresh repositories
		\item \texttt{apt}-\texttt{get upgrade} -- upgrade packages
		\item \texttt{apt}-\texttt{get dist}-\texttt{upgrade} -- upgrade to newer release of whole distribution
		\item \texttt{apt}-\texttt{cache search \textit{term}} --- search \textit{term}
		\item \texttt{apt}-\texttt{get autoremove} --- clear packages
		\item \texttt{aptitude} --- interactive manager
		\item \texttt{cat /etc/apt/sources.list} --- list repositories
		\item \texttt{nano /etc/apt/sources.list} --- add/remove/edit repositories
		\item \texttt{dpkg}-\texttt{*}, \texttt{apt}-\texttt{*} commands for other tasks
		\item \texttt{aptitude} is used in similar way as \texttt{apt}-\texttt{get} (e.g. \texttt{aptitude install \textit{package}},~\ldots)
		\item \texttt{man aptitude}, \texttt{man apt}-\texttt{XXX} (e.g. \texttt{man apt}-\texttt{get}), \texttt{man dpkg}-\texttt{XXX}, \texttt{man apt} --- usage help
	\end{itemize}
\end{frame}

\begin{frame}[allowframebreaks]{Package management in command line in RedHat, Fedora, CENTOS and derivatives (basic commands)}
	\begin{itemize}
		\item Root password is required: use \texttt{sudo\ldots} or \texttt{su}~-
		\item Package name \texttt{*.rpm}
		\item \texttt{dnf install \textit{package}} --- install \textit{package}
		\item \texttt{dnf remove \textit{package}} --- remove \textit{package}
		\item \texttt{dbf check}-\texttt{update} --- refresh repositories, check for updates
		\item \texttt{dnf upgrade} --- upgrade packages
		\item \texttt{dnf search \textit{term}} --- search \textit{term}
		\item \texttt{dnf autoremove} --- clear packages
		\item \texttt{dnf info \textit{package}} --- get information about \textit{package}
		\item \texttt{dnf repolist} --- list repositories
		\item \texttt{dnf config}-\texttt{manager} --- manage repositories and another settings
		\item \texttt{rpm} -\texttt{Uvh \textit{package}.rpm} --- install locally downloaded \texttt{\textit{package}.rpm}
		\item \texttt{rpm} -\texttt{e \textit{package}} --- remove \textit{package}
		\item \texttt{rpm*} commands for other tasks
		\item In older releases of Fedora, RedHat and CENTOS, \texttt{yum} is used instead of \texttt{dnf} in nearly identical way
		\item \texttt{man dnf} (or \texttt{man dnf}), \texttt{man rpm} --- usage help
	\end{itemize}
\end{frame}

\begin{frame}{Graphical package managers I}{Ubuntu Software, and Synaptic and text-based Aptitude for all DEB-based distributions}
	\includegraphics[width=\textwidth]{software_managers_ubuntu_deb.png}
\end{frame}

\begin{frame}{Graphical package managers II}{GNOME Software in Fedora and YaST in openSUSE}
	\includegraphics[width=\textwidth]{software_managers_fedora_suse.png}
	\begin{itemize}
		\item Practically every common general distribution has some graphical tool\ldots{ }Explore it\ldots
	\end{itemize}
\end{frame}

\begin{frame}{Manuals for package management}
	\begin{itemize}
		\item openSUSE and SUSE Linux Enterprise: \url{https://doc.opensuse.org/documentation/leap/startup/html/book.opensuse.startup/part.reference.software.html} and \url{https://en.opensuse.org/Portal:Zypper}
		\item Red Hat, Fedora, CENTOS, Scientific Linux and others: \url{http://yum.baseurl.org/} and newer \url{https://fedoraproject.org/wiki/DNF}
		\item Debian (and derivatives): \url{https://www.debian.org/doc/manuals/debian-reference/ch02.en.html} and \url{https://wiki.debian.org/PackageManagement}
		\item Ubuntu (and derivatives): \url{https://help.ubuntu.com/stable/ubuntu-help/addremove.html} and \url{https://help.ubuntu.com/community/AptGet/Howto}
		\item And another distributions\ldots
	\end{itemize}
\end{frame}

\subsection{Compilation}

\begin{frame}[fragile]{Basics of compilation}
	\begin{itemize}
		\item Some software is distributed only as source code written in languages like C or C++ --- user has to compile it to get binary executable
		\item Compilation creates binary specific for particular operating system and hardware platform --- can be tuned for optimal performance
		\item Interpreted languages like Bash, Perl, Python or Java don't have to be compiled (but it is possible) --- they need their interpreter to run, relative easily portable among hardware platforms and OS
		\item Applications requiring compilation usually have good instructions
		\item \textbf{If you don't have to do it, don't do it.}\textbf{} Solving problems can be complicated --- contact someone skilled or author of the application\ldots
	\end{itemize}
	\begin{bashcode}
    # General schema within application directory with the source code:
    ./configure # Many possible parameters, settings for compilation
                # Not required every time
    make # Basic building command, sometimes only this is required
    make install # Final creation of binary, sometimes required
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{Install tools needed for compilation}
	\begin{itemize}
		\item You need to install compilation tools for your distribution and programming languages you are going to use
		\item Commonly, extra dependencies are required to compile the application
		\begin{itemize}
			\item Packages for compilation use to end with -\texttt{dev} or -\texttt{devel} (e.g. if the software requires package \texttt{zlib} to run, install also its developmental version \texttt{zlib}-\texttt{dev(el) }to be able to compile it)
			\item All requirements should be listed in README or INSTALL documents of particular package --- user must install them manually\ldots
		\end{itemize}
	\end{itemize}
	\begin{bashcode}
    # openSUSE and SUSE Linux Enterprise
    zypper in -t pattern devel_basis devel_C_C++
    # Debian, Ubuntu and derivatives like Linux Mint and others
    apt-get install build-essential # Or "aptitude install build-essential"
    # Red Hat, CENTOS, Scientific Linux, Fedora and derivatives (2 options)
    dnf groupinstall "Development Tools" "C Development Tools and Libraries"
    yum groupinstall "Development Tools" "C Development Tools and Libraries"
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{Compilation of RAxML}
	\begin{itemize}
		\item Available from \url{https://github.com/stamatak/standard-RAxML} (cite \href{https://academic.oup.com/bioinformatics/article/30/9/1312/238053}{Stamakis 2014})
		\item Before compilation check \href{https://github.com/stamatak/standard-RAxML/blob/master/README}{README}
		\item This example does not require to run \texttt{make install}, it does not have extra dependencies for compilation, it requires specifying of particular source file by \texttt{make}~-\texttt{f} (there are multiple \texttt{GCC} files, no one main)
	\end{itemize}
	\begin{bashcode}
    mkdir raxml # Create working directory
    cd raxml/ # Go there
    # Get source code from GitHub (svn downloads only changed files)
    svn co https://github.com/stamatak/standard-RAxML/tags/v8.2.11
    cd v8.2.11/ # Go to newly created directory
    ls # List files
    rm -rf Windows* # No need of Windows version - delete it
    # Compile standard version (other versions are available for better CPU)
    make -f Makefile.gcc
    rm *.o # Remove unneeded files (temporal for compilation)
    ./raxmlHPC -h # Launch it - see RAxML help
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{Compilation of SAMtools}
	\begin{itemize}
		\item See \url{http://www.htslib.org/download/}
		\item Ensure packages \texttt{zlib} and \texttt{zlib}-\texttt{dev(el)} are installed --- required for running and compilation, see \href{https://github.com/samtools/samtools/blob/master/INSTALL}{INSTALL} and \href{https://github.com/samtools/samtools/blob/master/README}{README}
	\end{itemize}
	\begin{bashcode}
    wget https://github.com/samtools/samtools/releases/download/1.7/
      samtools-1.7.tar.bz2 # Download SAMtools
    tar xjvf samtools-1.7.tar.bz2 # Unpack the archive
    cd samtools-1.7/ # Go to the unpacked directory
    ./configure # Configure settings for compilation
    ./configure --help # See various configuring options
    ./configure --without-curses # Compile without ncurses support
    make # Compile the software - check if there is error
         # Ensure developmental files for zlib (and ncurses) are available
    make install # Copy products into final location - default /usr/local
    make prefix=/where/to/install install # Install into custom location
    make prefix=/home/$USER/bin install # Binary is in /home/$USER/bin/bin
    make clean # Cleanup - final files are already in the destination
	\end{bashcode}
\end{frame}

\subsection{Java}

\begin{frame}[fragile]{Launching Java applications}
	\begin{itemize}
		\item \href{https://www.java.com/}{Java} is probably the most portable language working on any operating system --- the only condition is to install \href{https://en.wikipedia.org/wiki/Java_virtual_machine}{Java virtual machine (JVM)}
		\item Linux usually use \href{https://openjdk.java.net/}{OpenJDK} --- search for packages named \texttt{*openjdk*}
		\item Let's download e.g. \href{http://tree.bio.ed.ac.uk/software/figtree/}{FigTree} from \url{http://tree.bio.ed.ac.uk/download.php?id=96&num=3}
	\end{itemize}
	\begin{bashcode}
    # Go to directory where you downloaded it
    cd directory/with/downloaded/figtree
    # Decompress downloaded archive
    tar zxvf FigTree_v1.4.3.tgz
    # Go to created directory
    cd FigTree_v1.4.3/
    ls * # List files, also in subdirectories
    # Launch it (command java launches *.jar files)
    java -jar lib/figtree.jar
    # Limit its memory usage to 128 MB
    java -Xmx128m -jar lib/figtree.jar
	\end{bashcode}
\end{frame}

\subsection{Windows applications}

\begin{frame}[allowframebreaks]{Windows applications on Linux}
	\begin{itemize}
		\item Applications written for one operating system do not work on the other systems\ldots
		\begin{itemize}
			\item They must be written in portable language like Java or script like Perl, Python or BASH
			\item Otherwise we need an emulator --- not everything works
		\end{itemize}
		\item Windows 10 has \href{https://docs.microsoft.com/windows/wsl/install-win10}{possibility to run Linux applications}, other option (for more Windows versions) is \href{https://www.cygwin.com/}{Cygwin} (application must be specially compiled to support Cygwin)
		\item To run Windows applications on Linux use \href{https://www.winehq.org/}{Wine}
		\begin{itemize}
			\item Search for packages named \texttt{wine} and install it
			\item Sometimes, extra functionality is in extra packages --- check \texttt{wine}-\texttt{*}
		\end{itemize}
		\item To run DOS application on Linux use \href{https://www.dosbox.com/}{dosbox} (package \texttt{dosbox})
		\item As soon as Wine is installed, just click to Windows \texttt{*.exe} file\ldots
		\item Windows applications are installed into \texttt{$\sim$/.wine/} where Windows directory structure is created, launchers use to be placed to standard application menu into \textbf{Wine} section
		\item Use \texttt{winecfg} to change settings (e.g. version of Windows --- can be different for each application, custom DLL library,~\ldots)
		\item \texttt{winefile} starts Windows file browser, \texttt{notepad} Notepad, \texttt{winemine} Mines
		\item To install some extra parts required by some applications use \texttt{winetricks}
		\begin{itemize}
			\item Usage use to differ according to distribution and GUI
			\item Browsing and selecting items to install can be bit messy\ldots
			\item It can be hard to check application requirements --- if it fails, check if it is listed at \url{https://appdb.winehq.org/} and/or run it from command line like \texttt{wine application.exe} and inspect errors in output
		\end{itemize}
		\item Before installing Windows application under Wine, check if there is some native Linux application to fit your needs\ldots
		\begin{itemize}
			\item Plenty of applications are available for more operating systems
			\item Linux distributions use to have external contributor's sites to provide more packages
			\item For many Windows-only applications there are fully comparable alternatives
		\end{itemize}
		\item Some applications do not work under Wine (from various reasons), some complex packages are \href{https://www.codeweavers.com/}{supported commercially} (I~have no experience with it)
		\item Wine is well compatible with rest of the Linux hosting system, it is considerable to install Windows in e.g. VirtualBox (or another virtualization platform), if needed
	\end{itemize}
\end{frame}

\begin{frame}{winefile, winetricks and winecfg}
	\includegraphics[width=\textwidth]{wine.png}
\end{frame}

\section{MetaCentrum}

\begin{frame}{MetaCentrum}
	\tableofcontents[currentsection, sectionstyle=show/hide, hideothersubsections]
\end{frame}

\subsection{Information}

\begin{frame}[allowframebreaks]{CESNET and MetaCentrum}
	\label{CESNET}
	\begin{itemize}
		\item \href{https://www.cesnet.cz/?lang=en}{CESNET} is organization of Czech universities, Academy of Science and other organizations taking care about Czech backbone Internet, one of world leading institutions of this type
		\item CESNET provides various \href{https://www.cesnet.cz/services/?lang=en}{services}
		\begin{itemize}
			\item Massive computations --- \href{https://www.cesnet.cz/services/massive-computations-metacentrum/?lang=en}{MetaCentrum}
			\item Large \href{https://www.cesnet.cz/services/data-storage/?lang=en}{data storage}
			\item \href{https://www.cesnet.cz/services/filesender/?lang=en}{FileSender} to be able to send up to 500~GB file
			\item \href{https://www.metacentrum.cz/en/Sluzby/MetaCloud/}{MetaCloud} --- computing (HPC) cloud similar to e.g. Amazon Elastic Compute Cloud (EC2) or Google Compute Engine
			\item \href{https://www.cesnet.cz/services/owncloud/?lang=en}{ownCloud} to backup and/or sync data across devices (default capacity is 100~GB, user may ask for more) --- similar to e.g. Dropbox
			\begin{itemize}
				\item It is possible to connect by webDAV to ownCloud (slide \ref{transfers}) --- many applications support it
				\item It is possible to share calendars and/or address books via calDav and cardDav among devices and/or people
			\end{itemize}
		\end{itemize}
		\item Services accessible without registration
		\begin{itemize}
			\item ownCloud \url{https://owncloud.cesnet.cz/}
			\item FileSender \url{https://filesender.cesnet.cz/}
			\item Go to web and log in with your institutional password
		\end{itemize}
		\item Services requiring registration (and approval)
		\begin{itemize}
			\item To use MetaCentrum fill registration form \url{https://metavo.metacentrum.cz/en/application/form}
			\item To use data storage fill registration form \url{https://einfra.cesnet.cz/perun-registrar-fed/?vo=storage}
			\item After registration for MetaCentrum, user can join MetaCloud via \url{https://perun.metacentrum.cz/fed/registrar/?vo=meta&group=metacloud}
			\item Users not having access to \href{https://www.eduid.cz/en/index}{EduID} have to register first at HostelID \url{https://hostel.eduid.cz/en/}
			\item Note some browser do not have required certificate and registration pages do not work correctly. \href{https://www.mozilla.org/firefox/}{Mozilla Firefox} should be safe choice every time.
		\end{itemize}
		\item Information about data storage \url{https://du.cesnet.cz/en/start} contains detailed usage instructions
		\item Information about MetaCentrum \url{https://www.metacentrum.cz/en/}
		\item Information about MetaCloud \url{https://wiki.metacentrum.cz/wiki/Kategorie:Clouds}
		\item Most of practical information for users are at wiki \url{https://wiki.metacentrum.cz/w/index.php?&setlang=en}
	\end{itemize}
\end{frame}

\begin{frame}{MetaCentrum}
	\begin{itemize}
		\item Also available is Galaxy \url{https://galaxy.metacentrum.cz/galaxy/} (same login as to MetaCentrum) --- web based bioinformatics framework (more information at \href{https://wiki.metacentrum.cz/wiki/Galaxy}{wiki})
		\item Current state and usage as available at \url{https://metavo.metacentrum.cz/en/}
		\item Manage your user account at \url{http://metavo.metacentrum.cz/en/myaccount/}
		\item Personal view on actual resources and running tasks is at \url{https://metavo.metacentrum.cz/pbsmon2/person}
		\item List of available applications \url{https://wiki.metacentrum.cz/wiki/Kategorie:Applications}
		\item It has 8~front ends where users log and thousands of computers doing the calculations --- they are not accessed directly to run task
		\item Most of computers are running \href{https://www.debian.org/}{Debian GNU/Linux}
	\end{itemize}
\end{frame}

\subsection{Usage}

\begin{frame}[fragile]{MetaCentrum usage}
	\begin{itemize}
		\item User can transfer data on one of \href{https://wiki.metacentrum.cz/wiki/Frontend}{frontends} (next slide) by e.g. \texttt{scp} or \href{https://winscp.net/}{WinSCP} from Windows
		\item Same credentials are used for all front ends, for SSH login as well as file transmissions
	\end{itemize}
	\begin{bashcode}
    # Login to selected server (tarkil is located in Prague)
    ssh USER@tarkil.metacentrum.cz
    # Continue as in any other command line...
    qsub ... # Submit the job (see later)
	\end{bashcode}
	\begin{itemize}
		\item In home directory on the server prepare all needed data and non-interactive script (interactive are more complicated) which will do the calculations
		\item Tasks are not launched immediately, but using \texttt{qsub} the task is submitted into queue and system decides when it will be launched
	\end{itemize}
\end{frame}

\begin{frame}{File transfers to MetaCentrum}
	\begin{itemize}
		\item Graphical applications: \href{https://www.gftp.org/}{gFTP}, \href{https://filezilla-project.org/}{FileZilla} or from most of file managers
		\item Protocol is SSH/SSH2/SFTP/SCP, port 22, server is selected \href{https://wiki.metacentrum.cz/wiki/Frontend}{frontend's} address (e.g. \texttt{tarkil.metacentrum.cz}) --- it is recommendable to use all the time same front end
		\item All servers are accessible under domain \texttt{*.metacentrum.cz}: \texttt{skirit}, \texttt{perian}, \texttt{onyx}, \texttt{zuphux} (located in Brno), \texttt{alfrid}, \texttt{nympha}, \texttt{minos} (in Pilsen), and \texttt{tarkil} (in Prague) --- so that e.g. \texttt{tarkil.grid.cesnet.cz} is synonymous to \texttt{tarkil.metacentrum.cz}
		\item See slide \ref{transfers} and following to command-line transfers of files
	\end{itemize}
	\includegraphics[width=\textwidth]{gftp.png}
\end{frame}

\subsection{Tasks}

\begin{frame}[fragile]{Basic skeleton of script running tasks I}
	\begin{bashcode}
    #!/bin/bash
    # Modify the script according to your needs!
    # Set data directories
    WORKDIR="my_data_dir" # Or something else
    DATADIR="/storage/praha1/home/$LOGNAME" # Or other storage
    # There is directory /storage/praha1/home/USER/my_data_dir
    # (in this case) containing all the data needed for calculations
    # Clean-up of SCRATCH (it is temporal directory created by server)
    # - the commands will be launched on the end when the job is done
    trap 'clean_scratch' TERM EXIT
    trap 'cp -a "$SCRATCHDIR" "$DATADIR"/ && clean_scratch' TERM
    # Prepare the task - copy all needed files from working directory
    # into particular computer which will finally do the calculations
    cp -a "$DATADIR"/"$WORKDIR"/* "$SCRATCHDIR"/ || exit 1 # If fails, exit
    # Change working directory - script goes to the directory where
    # calculations are done
    cd "$SCRATCHDIR"/ || exit 2 # If it fails, exit script
	\end{bashcode}
	\vfill
	Ends on following slide\ldots
	\vfill
\end{frame}

\begin{frame}[fragile]{Basic skeleton of script running tasks II}
	\ldots begins on previous slide\ldots
	\vfill
	\begin{bashcode}
    # Prepare calculations - load required application modules
    # See https://wiki.metacentrum.cz/wiki/Kategorie:Applications
    # Every application module is loaded by "module add XXX"
    module add parallel # In this (example) case GNU Parallel and MrBayes
    module add mrbayes-3.2.6
    # Launch the analysis - calculate MrBayes for multiple files
    # Note Parallel will distribute task among 8 CPU threads (-j 8),
    # so that qsub must in this case contain select=1:ncpus=8 (see further)
    find . -name "*.nexus" -print | parallel -j 8 'mb {} | tee -a {}.log'
    # Copy results back to home directory
    cp -a "$SCRATCHDIR" "$DATADIR"/"$WORKDIR" || export CLEAN_SCRATCH=false
    # This is all needed, the script is ready to be launched...
    exit
	\end{bashcode}
	\begin{itemize}
		\item Make \texttt{metacentrum.sh} executable and modify it to fit your needs\ldots
		\item If it was written on Windows, convert EOL (and encoding)\ldots
	\end{itemize}
	\vfill
\end{frame}

\begin{frame}[fragile]{Launching of tasks}
	\begin{itemize}
		\item \url{https://wiki.metacentrum.cz/wiki/How_to_compute/Requesting_resources}
		\item Personal view \url{https://metavo.metacentrum.cz/pbsmon2/person} has nice overview of available resources and tasks and allows comfortable construction of submission command
	\end{itemize}
	\begin{bashcode}
    # We will run up to 5 days (120 hours), require one physical computer
    # with 8 CPU threads, 24 GB of RAM, 10 GB of disk space and we get all
    # information mails (for abort, beginning, exit)
    qsub -l walltime=120:0:0 -l select=1:ncpus=8:mem=24gb:scratch_local=10gb
      -m abe metacentrum.sh
    # Check how the task is running (above web) and
    qstat -u $USER # Or qstat | grep $USER
    qstat 123456789 # The task ID is available from commands above or mail
    qstat -f 123456789 # Print a lot of details
    qdel 123456789 # Terminate scheduled or running task
	\end{bashcode}
\end{frame}

\begin{frame}[allowframebreaks]{Scheduling details}
	\begin{itemize}
		\item Specify needed time
		\begin{itemize}
			\item Always \texttt{hours:minutes:seconds}, so e.g. for 4~weeks use -\texttt{l~walltime=672:00:00} (28~$\cdot$~24), for two days and 12 hours -\texttt{l~walltime=60:00:00}
			\item User \href{mailto:meta@cesnet.cz}{may ask} to prolong the walltime --- it is needed to write in advance
		\end{itemize}
		\item Ask for as much RAM as you need (e.g. -\texttt{l~mem=8gb} to request 8~GB)
		\begin{itemize}
			\item If the task is going to require more, than allowed, system kills it\ldots
			\item If user doesn't use all required RAM, the system temporarily lowers priority for future tasks
			\item It can be hard to estimate\ldots
		\end{itemize}
		\item Disk space is relatively free resource, user can ask more to have some reserve (e.g. -\texttt{l~scratch\_local=10gb} to request 10~GB)
		\item Specify how many physical computer(s) you are going to use (e.g. -\texttt{l~select=1} for one machine) and number of CPU threads on each machine (e.g. -\texttt{l~select=1:ncpus=8} for 1~machine with 8~cores or -\texttt{l~select=2:ncpus=4} for 2~machines, each with 4~CPU threads)
		\begin{itemize}
			\item It use to be necessary to specify correct number of threads for the application (e.g. \texttt{parallel}~-\texttt{j 4}) --- the application sees all CPUs on the machine, but can't use them
			\item If the application consumes less than required, the system temporarily lowers priority for future tasks, if it try to use more, it will be very slowed down or killed by the server
			\item If using more physical machines, ensure correct settings of e.g. MPI (see documentation for respective software you are using)
		\end{itemize}
		\item If requesting e-mails (e.g. -\texttt{m abe} to get mail about abort, beginning and exit of the task) and submitting plenty of tasks by some script, it can result in hundreds of mails --- receiving mail servers don't like it\ldots
		\item Every user has certain \href{https://metavo.metacentrum.cz/pbsmon2/users/}{priority} highered by \href{https://wiki.metacentrum.cz/wiki/Usage_rules/Acknowledgement}{acknowledgments} in publications to MetaCentrum and lowered by intensive usage of the service (the usage is calculated from past month)
		\item After submission of the task, check in \href{https://metavo.metacentrum.cz/pbsmon2/queues/jobsQueued}{the queue} in which state it is --- sometimes it can't start because of impossible combination of resources or so
		\item User can \href{https://metavo.metacentrum.cz/pbsmon2/nodes/physical}{check load of machines}
		\item For more options read \url{https://wiki.metacentrum.cz/wiki/How_to_compute/Requesting_resources}
		\begin{itemize}
			\item Request special CPU (AMD, graphical,~\ldots), e.g. CPU with AVX2 -\texttt{l~select=cpu\_flag=avx2}
			\item SSD local storage (e.g. -\texttt{l~scratch\_ssd=1gb})
			\item Request particular location, ...
			\item \url{https://metavo.metacentrum.cz/pbsmon2/qsub_pbspro} helps with preparation of \texttt{qsub} command
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Common problems with launching the tasks}
	\begin{itemize}
		\item Script fails because of wrong PATH or missing file --- ensure all needed files are transferred and applications receive correct paths
		\begin{itemize}
			\item Rather do not use absolute paths (starting with \texttt{/}) --- only relative
		\end{itemize}
		\item Not all required applications are correctly loaded
		\begin{itemize}
			\item Check \href{https://wiki.metacentrum.cz/wiki/Kategorie:Applications}{wiki} and load all needed applications
			\item Names of binaries are sometimes little bit different --- contain names of versions, etc.
		\end{itemize}
		\item Estimation of time needed to run the task
		\begin{itemize}
			\item No really good solution\ldots
			\item Make some trials and try to estimate\ldots
			\item There are very different CPUs available (with different speeds) --- it is possible to require particular CPU type (but it reduces number of available nodes\ldots)
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Get to task's working directory}
	\begin{itemize}
		\item Go to \url{https://metavo.metacentrum.cz/pbsmon2/person} and click to list of your tasks and click to selected task
		\item Search for information \textbf{exec\_host} (address of node doing the task) and \textbf{SCRATCHDIR} (temporal directory for all data and results)
		\item Sometimes one needs to monitor task progress or influence it
		\item It is not possible to directly modify running task, but at least check (and possibly modify) input data and see outputs
	\end{itemize}
	\begin{bashcode}
    # From MetaCentrum front end login to respective node running the task
    ssh exec_host # No need to specify user name; e.g. mandos9
    # Go to SCRATCH directory
    cd SCRATCHDIR # e.g. /scratch/gunnera/job_1234567.arien-pro.ics.muni.cz
    # There are working data of currently running task...
    # Check whatever you need...
    tee # Command recording outputs or software, normal output of software
        # is written into log, which is unavailable until the task is over
	\end{bashcode}
\end{frame}

\begin{frame}{Running R tasks on MetaCentrum}
	\begin{itemize}
		\item There are no R packages, user must create local package library and provide path
		\item \alert{Be careful about paths!}
		\item In the \texttt{metacentrum.sh} script load R \texttt{module add R-3.3.1-intel} and start R script as usually \texttt{R CMD BATCH script.r}
	\end{itemize}
	\begin{enumerate}
		\item Login to selected front node via SSH
		\item Go to working directory \texttt{cd workdir}
		\item Create new directory for R packages \texttt{mkdir rpkgs}
		\item Start R \texttt{R}
		\item Install \textbf{all} R packages needed for the task --- install them into the \texttt{rpkgs} directory \texttt{install.packages(pkgs=..., lib="rpkgs")}
		\item In the R script \texttt{*.r} load the packages from the \texttt{rpkgs} directory \texttt{library(package=..., lib.loc="rpkgs")}
		\item Ensure all needed outputs are saved from the R script
	\end{enumerate}
\end{frame}

\begin{frame}[fragile]{Interactive tasks}
	\begin{itemize}
		\item See information at \url{https://wiki.metacentrum.cz/wiki/How_to_compute/Interactive_jobs}
	\end{itemize}
	\begin{bashcode}
    # Again launch qsub according to actual needs
    # Note "-I" for interactive session and missing script name
    qsub -I -l walltime=2:0:0 -l select=1:ncpus=1:mem=2gb:scratch_local=1gb
    # Wait for job to start..
    # After we get the interactive task, we are on new server
    hostname # See where we are - we can connect to that server directly
    ssh USER@given.server.cz # User name and password are the same
                             # Server address is output from "hostname"
    screen # Secure we can log off in the meantime
    # When you logout, the task is done (use screen to secure connection)
	\end{bashcode}
	\begin{itemize}
		\item Work as on normal Linux server\ldots
		\item With \texttt{screen} we can disconnect as usually and let tasks run in background
	\end{itemize}
\end{frame}

\subsection{Graphical connection}

\begin{frame}[fragile]{Graphical interactive task}
	\begin{itemize}
		\item See information at \url{https://wiki.metacentrum.cz/wiki/Remote_desktop}
	\end{itemize}
	\begin{bashcode}
    # Again launch qsub according to actual needs
    # Note "-I" for interactive session and missing script name
    qsub -I -l walltime=2:0:0 -l select=1:ncpus=1:mem=2gb:scratch_local=1gb
    # Wait for job to start..
    # After we get the interactive task, we are on new server
    screen # Secure we can log off in the meantime
    module add gui # We need to add GUI module
    gui start # Start GUI (see above link for details)
    gui info -p # Print information about running VNC sessions
                # Including address, port and password to connect
	\end{bashcode}
	\begin{itemize}
		\item Launch your favorite VNC client (\href{https://www.kde.org/applications/internet/krdc/}{KRDC}, \href{https://www.tightvnc.com/}{TightVNC},~\ldots) and use credentials from above output to connect
		\item Work as on normal Linux desktop\ldots
		\item With \texttt{screen} we can disconnect as usually
		\item It provides limited amount of resources, not suitable for big tasks
	\end{itemize}
\end{frame}

\begin{frame}{Running VNC}
	\includegraphics[width=\textwidth]{vnc.png}
\end{frame}

\subsection{Data storage}

\begin{frame}{CESNET data storage}
	\begin{itemize}
		\item Read documentation \url{https://du.cesnet.cz/} and connection instructions \url{https://du.cesnet.cz/en/navody/sluzby/start}
		\item See slide~\ref{CESNET} for general information and \ref{transfers} for connecting information
		\item Generally, it is possible to connect via FTPS, NFS, SAMBA (Windows network drive), SCP/SFTP or SSH
		\item After logging via SSH, it is possible to work as on any other server
		\item Users get information about selected storage location and paths after registration (there are three locations, user get space on one of them)
		\item All storage locations are accessible from any MetaCentrum front node via directories in \texttt{/storage} (e.g. \texttt{/storage/ostrava2}-\texttt{archive/tape\_tape/VO\_cuni\_prf\_...})
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Shared space on CESNET data storage}
	\begin{itemize}
		\item Users \href{https://du.cesnet.cz/en/uzivatelska_podpora/start}{can ask} for creation of shared space
		\begin{itemize}
			\item Normally, the space is private only for particular user
			\item Groups allow more users to share data
			\item Data storage admins will instruct users regarding locations, paths, permissions, etc. (it is specific for each case)
		\end{itemize}
		\item Users must carefully set permissions!
		\begin{itemize}
			\item Sharing is done by specific UNIX group
			\item Users must set group ownership to particular group and permissions e.g. 770 for directories and 660 for files to avoid access of any other users
			\item All members of the group must be able to manipulate the data
		\end{itemize}
	\end{itemize}
	\begin{bashcode}
    # Change group ownership to XXX
    chgrp -R XXX /tape_tape/VO_XXX 2>/dev/null
    # ("-R" to modify also subdirectories; "2>/dev/null" to discard errors)
    # Set correct permissions to directories and files
    find /tape_tape/VO_XXX -type d -exec chmod 770 {} \;
    find /tape_tape/VO_XXX -type f -exec chmod 660 {} \;
	\end{bashcode}
\end{frame}

% \subsection{Cloud} % TODO MetaCloud
%
% \begin{frame}{MetaCloud}
% 	\begin{itemize}
% 		\item
% 	\end{itemize}
% \end{frame}

\section{Git} % TODO More general info about Git, separate GitHub to extra slide

\begin{frame}{Git}
	\tableofcontents[currentsection, sectionstyle=show/hide, hideothersubsections]
\end{frame}

\begin{frame}[fragile]{Git and GitHub}
	\begin{itemize}
		\item \href{https://git-scm.com/}{Git} is \href{https://en.wikipedia.org/wiki/Version_control}{version controlling} system --- it traces changes among all versions --- absolutely crucial for any software development
		\item \href{https://github.com/}{GitHub} is currently probably the most popular platform to host development of open-source projects, see \href{https://help.github.com/}{documentation}
		\item Older (nowadays not so common) version controlling systems is Subversion (SVN), there are many more (Bazaar,~\ldots)
		\item Probably the best textbook for Git is \href{https://git-scm.com/book/en/v2}{Chacon's Pro Git}
		\begin{itemize}
			\item Dostupná i~\href{https://git-scm.com/book/cs/v2}{česky} (včetně \href{https://knihy.nic.cz/}{prvního vydání})
		\end{itemize}
		\item Changes and their history is stored in repository (local or network, shared or private) --- it is possible to view any historical state and differences between any versions
		\item It is possible to trace who and when did what
		\item Branching and merging of branches helps with making of big changes
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Git principles}
	\begin{multicols}{2}
		\begin{itemize}
			\item Three main areas
			\begin{enumerate}
				\item Working directory
				\item Staging (changes awaiting to be pushed to the repository)
				\item Git repository (remote/local)
			\end{enumerate}
			\item Everyone has whole repository and history --- very robust
			\item Flexible branches
			\begin{itemize}
				\item Very convenient
				\item Keeping work structured
				\item Separation of tasks
				\item Keeping more versions of the project in parallel
			\end{itemize}
		\end{itemize}
		\begin{center}
			\includegraphics[height=5.75cm]{git.png}
		\end{center}
		\begin{flushright}
			\begin{footnotesize}
				\href{https://git-scm.com/book/en/v2/Getting-Started-Git-Basics}{https://git-scm.com/}, \href{https://nvie.com/posts/a-successful-git-branching-model/}{https://nvie.com/}
			\end{footnotesize}
		\end{flushright}
	\end{multicols}
\end{frame}

\begin{frame}[fragile]{Working with Git --- start and sending changes}
	\begin{bashcode}
    # Create a new repository for new project
    git init # No need when cloning from existing repository
    # Or checkout (make a copy) for another local or remote repository
    git clone /path/to/local/repository # Locally mounted repository
    git clone username@host:/path/to/remote/repository # Over SSH
    git clone https://github.com/V-Z/course-linux-command-line-bash-
      scripting-metacentrum.git # Clone from web, e.g. GitHub
    # Add files to trace with Git
    # Ignored files (or patterns) can be listed in .gitignore file
    git add <files> # Or "git add *"
    # Commit changes to prepare then to send to repository
    git commit -m "Message..."
    # If you did not start by cloning, add connection to server
    git remote add origin <location> # Do only once on the beginning
    # <location> can be remote server or local path
    git remote add origin . # For repository within working directory
    # Push changes into the repository (regardless where it is)
    git push origin master # See further for selection of branches
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{Working with Git --- branching and getting changes}
	\begin{bashcode}
    # Making new branch and switching to it
    git checkout -b NewFeature # Now we are in branch NewFeature
    # Switch back to branch master
    git checkout master # Generally, "git checkout <branch>"
    # Delete the branch (changes there are lost, must be in another branch)
    git branch -d NewFeature # Delete local branch
    git push origin --delete <branch> # Delete remote branch
    # New branch must be also pushed to the remote server
    git push origin <branch>
    # List branches (current is marked by asterisk on the beginning)
    git branch
    # Download news from central server
    git fetch
    # Update local repository to the newest version from central repository
    git pull # Fetch and merge remote changes (before commit)
    # Merge another branch into the current one
    git merge <branch>
    # In case of conflict, git shows editor and user must fix it manually
    git add <file with conflict> # Needed to re-add conflicting file
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{Working with Git --- tags, logs and settings}
	\begin{bashcode}
    # To see changes before merging
    git diff <source_branch> <target_branch>
    # Tagging e.g. milestones, released versions of software, etc.
    git tag <name> <commit id> # <name> can be custom, <commit id> from log:
    git log # Newest is on top, see also "git log --help"
    git log --graph --oneline --decorate --all # Full long log
    # Discard local changes for particular file
    git checkout --- <file>
    # Discard all local changes
    git fetch origin # Overwrite local changes
    git reset --hard origin/master # If local repository is broken...
    gitk # Graphical interface
    git config color.ui true # Set output to be colored
    git config format.pretty oneline # Nicer log output
    ~/.git # Contains user's settings, .git in every repository contains
           # data and settings for particular repository
	\end{bashcode}
\end{frame}

\section{Administration}

\begin{frame}{Administration}
	\tableofcontents[currentsection, sectionstyle=show/hide, hideothersubsections]
\end{frame}

% \begin{frame}{Btrfs and Snapper} % TODO Btrfs, Snapper
% 	\begin{itemize}
% 		\item
% 	\end{itemize}
% \end{frame}

\subsection{System services}

\begin{frame}[fragile]{Managing system services}
	\begin{itemize}
		\item Different among distributions --- several main methods
		\item In Linux, most common is \href{https://wiki.freedesktop.org/www/Software/systemd/}{SystemD}, less common older init scripts and RC scripts
		\item macOS and various BSD and other systems have different methods
		\item Used to manage system services like networking, cron, web server, database,~\ldots
		\item \alert{Read documentation for your distribution first!}
		\item Most of actions require root authentication
	\end{itemize}
	\begin{bashcode}
    # SystemD - huge amount of possibilities
    systemctl enable/disable/status/start/stop servicename # TAB helps
    # RC scripts
    rcservicename status/start/stop # TAB helps to select service
    # Init scripts
    /etc/init.d/servicename status/start/stop # TAB helps to select service
	\end{bashcode}
\end{frame}

\begin{frame}[fragile]{SystemD usage}
	\begin{bashcode}
    # List installed services and their status
    systemctl list-units --type service
    # Enable/disable/see status/start/stop/restart/... service
    systemctl enable/disable/status/start/stop/restart servicename # TAB...
    # Show overridden config files after upgrade
    systemd-delta
    # Analyze boot time (how long does each service take to start)
    systemd-analyze blame # Text output
    systemd-analyze plot > filename.svg # Same in graphics
    # Log for particular service
    journalctl -u servicename
    # Last logged messages (press Ctrl+C to exit)
    journalctl -f
    # Log records since last boot
    journalctl -b
    # Time and date information and management
    timedatectl
    # And much more...
	\end{bashcode}
\end{frame}

% \begin{frame}{Security} % TODO Security, antiviruses
% 	\begin{itemize}
% 		\item
% 	\end{itemize}
% \end{frame}

\section{The End}

\begin{frame}{The End}
	\tableofcontents[currentsection, sectionstyle=show/hide, hideothersubsections]
\end{frame}

% \subsection{Switching to Linux} % TODO Switching
%
% \begin{frame}[allowframebreaks]{Brief list of applications to help to switch to Linux}
% 	\begin{itemize}
% 		\item
% 	\end{itemize}
% \end{frame}

\subsection{Resources}

\begin{frame}[allowframebreaks]{Resources to learn to work in the terminal}
	\begin{itemize}
		\item openSUSE (general handbook) \url{https://doc.opensuse.org/documentation/leap/startup/html/book.opensuse.startup/part.bash.html}
		\item Ubuntu (general handbook) \url{https://help.ubuntu.com/community/UsingTheTerminal}
		\item BASH full reference manual \url{https://www.gnu.org/software/bash/manual/} (advanced)
		\item Debian (general handbook) \url{https://www.debian.org/doc/manuals/debian-reference/ch01.en.html}
		\item Guide to Unix \url{https://en.wikibooks.org/wiki/Guide_to_Unix}
		\item BASH for beginners \url{https://www.tldp.org/LDP/Bash-Beginners-Guide/html/Bash-Beginners-Guide.html} (the site has plenty of good resources)
		\item Grymoire for UNIX wizards \url{http://www.grymoire.com/Unix/}
		\item BASH Guide for Beginners \url{http://linuxcourse.rutgers.edu/documents/Bash-Beginners-Guide/}
		\item Linux tutorial \url{https://ryanstutorials.net/linuxtutorial/}
		\item Getting Started with BASH \url{https://www.hypexr.org/bash_tutorial.php}
		\item Bash Guide \url{https://mywiki.wooledge.org/BashGuide}
		\item Česky
		\begin{itemize}
			\item Učebnice Linuxu \url{https://www.abclinuxu.cz/ucebnice}
			\item Příkazová řádka Ubuntu \url{http://wiki.ubuntu.cz/syst\%C3\%A9m/p\%C5\%99\%C3\%ADkazov\%C3\%A1_\%C5\%99\%C3\%A1dka/termin\%C3\%A1l}
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[allowframebreaks]{How to ask for help}
	\label{howtoask}
	\begin{itemize}
		\item \alert{Never ever} ask simple silly lazy questions you can quickly find in manual or web
		\item People on mailing lists and forums respond volunteerly in their spare free time --- do not waste it --- be polite, brief and informative
		\item Be as specific and exact as possible
		\begin{itemize}
			\item Write \alert{exactly} what you did (\enquote{It doesn't work!} is useless\ldots)
			\item Copy/paste your commands and their output, especially error messages --- they are keys to solve the problem
			\item Try to search web for the error messages (or their parts)
			\item Try to provide minimal working example --- add at least part of your data (if applicable) so that the problem is reproducible
			\item Specify name and version of distribution and of the problematic software
		\end{itemize}
		\item \textbf{OSS is free as freedom of speech --- not as free beer!}
		\begin{itemize}
			\item As soon as you don't pay for support, you can't blame anyone for lack of responses
			\item There are plenty of reasons some software doesn't work --- usage/data author didn't expect, unsupported version of operating system, author's mistake, user's mistake,~\ldots
			\item Authors wish their software to be useful --- constructive feedback, reporting bugs and wishes is welcomed, but it must be provided in the way useful for the developer
		\end{itemize}
		\item Imagine you should answer --- which information do you need?
		\item Try to find the best place to ask your question --- specific forum for particular distribution or software use to be the best option
		\item Learning command line is like learning foreign language\ldots
		\item \alert{Reading documentation is not wasting of time!}
	\end{itemize}
\end{frame}

\begin{frame}[allowframebreaks]{Main general fora}
	\begin{block}{Question must have certain form!}
			Before asking, \alert{ensure your question is in answerable form} (previous slide).
		\begin{itemize}
			\item Sloppily asked question can't be answered at all\ldots
			\item Check documentation, manuals and search the Internet before asking
		\end{itemize}
	\end{block}
	\begin{itemize}
		\item Probably the best are fora from StackExchange \url{https://stackexchange.com/sites}
		\item General forum for programmers \url{https://stackoverflow.com/}
		\item UNIX forum \url{https://unix.stackexchange.com/}
		\item Forum for administrators \url{https://superuser.com/}
		\item Questions mainly (not only) related to servers \url{https://serverfault.com/}
		\item Do not hesitate to ask on the forum or contact developers, preferably through some public forum or mailing list, they usually respond quickly and helpfully\ldots{ }--- they wish their software to be working and useful
		\item \href{https://www.startpage.com/}{Uncle Google} is your friend here (\textit{\enquote{how to XXX in BASH/Linux}})\ldots
		\item Plenty of bigger projects have their own web fora or e-mail conferences --- search for it to ask on right place
		\item In Linux/OSS world, e-mail conferences and \href{https://en.wikipedia.org/wiki/Internet_Relay_Chat}{IRC} are sometimes more popular, than web forums --- try them
		\item If you find a~bug, report it according to instructions given by the project
	\end{itemize}
\end{frame}

\begin{frame}{openSUSE}
	\begin{itemize}
		\item Homepage \url{https://www.opensuse.org/}
		\item Wiki \url{https://en.opensuse.org/Main_Page}
		\item Documentation \url{https://doc.opensuse.org/}
		\item News \url{https://news.opensuse.org/}, developers' blogs \url{https://lizards.opensuse.org/}, aggregation of blogs \url{https://planet.opensuse.org/}
		\item Forums \url{https://forums.opensuse.org/}
		\item Mailing lists \url{https://lists.opensuse.org/}
		\item Community \url{https://opensuse-community.org/}, guide \url{https://opensuse-guide.org/}
	\end{itemize}
\end{frame}

\begin{frame}{Debian, Ubuntu, Linux Mint and derivatives}
	\begin{itemize}
		\item Debian \url{https://www.debian.org/}
		\begin{itemize}
			\item Documentation, wiki \url{https://wiki.debian.org/}
			\item Support \url{https://www.debian.org/support}
		\end{itemize}
		\item Ubuntu \url{https://www.ubuntu.com/}
		\begin{itemize}
			\item Support \url{https://www.ubuntu.com/support}
			\item Ask Ubuntu \url{https://askubuntu.com/}
			\item Forum \url{https://ubuntuforums.org/}
			\item Documentation \url{https://help.ubuntu.com/}
			\item Kubuntu \url{https://www.kubuntu.org/}
			\item Kubuntu forum \url{https://www.kubuntuforums.net/}
			\item Xubuntu \url{https://xubuntu.org/}
			\item Lubuntu \url{https://lubuntu.net/}
		\end{itemize}
		\item Linux Mint \url{https://www.linuxmint.com/}
		\begin{itemize}
			\item Documentation \url{https://www.linuxmint.com/documentation.php}
			\item Forums \url{https://forums.linuxmint.com/}
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Fedora}
	\begin{itemize}
		\item Homepage \url{https://getfedora.org/}
		\item Communication and help overview \url{https://fedoraproject.org/wiki/Communicating_and_getting_help}
		\item Wiki \url{https://fedoraproject.org/wiki/Fedora_Project_Wiki}
		\item Official forum \url{https://ask.fedoraproject.org/}
		\item Documentation \url{https://docs.fedoraproject.org/}
		\item Community forum \url{https://fedoraforum.org/}
	\end{itemize}
\end{frame}

\begin{frame}{GNOME, KDE and XFCE}
	\begin{itemize}
		\item GNOME \url{https://www.gnome.org/}
		\begin{itemize}
			\item Help for users \url{https://help.gnome.org/users/}
			\item Wiki \url{https://wiki.gnome.org/}
		\end{itemize}
		\item KDE \url{https://www.kde.org/}
		\begin{itemize}
			\item Forum \url{https://forum.kde.org/}
			\item UserBase wiki \url{https://userbase.kde.org/Welcome_to_KDE_UserBase}
			\item Application store \url{https://store.kde.org/}
			\item KDE for education \url{https://edu.kde.org/}
			\item Blogs \url{https://planet.kde.org/}
		\end{itemize}
		\item XFCE \url{https://xfce.org/}
		\begin{itemize}
			\item Documentation \url{https://docs.xfce.org/}
			\item Wiki \url{https://wiki.xfce.org/}
			\item Forum \url{https://forum.xfce.org/}
			\item Blogs \url{https://blog.xfce.org/}
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{LibreOffice}
	\begin{itemize}
		\item LibreOffice \url{https://www.libreoffice.org/}
		\begin{itemize}
			\item Document Foundation \url{https://www.documentfoundation.org/}
			\item Ask LO \url{https://ask.libreoffice.org/}
			\item Wiki of LO \url{https://help.libreoffice.org/Main_Page} and DF \url{https://wiki.documentfoundation.org/Main_Page}
			\item Documentation \url{https://documentation.libreoffice.org/en/english-documentation/}
		\end{itemize}
		\item Česky
		\begin{itemize}
			\item Novinky a~informace \url{https://www.openoffice.cz/}
			\item Fórum \url{https://forum.openoffice.cz/}
			\item Podrobná příručka \url{https://www.knihaoffice.cz/} (jedna z~vůbec nejlepších dostupných knih)
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[allowframebreaks]{České weby --- zdroje informací a~fóra}
	\begin{itemize}
		\item ABC Linuxu \url{https://www.abclinuxu.cz/}
		\item Root \url{https://www.root.cz/}
		\item LinuxExpres \url{https://www.linuxexpres.cz/}
		\begin{itemize}
			\item Správa linuxového serveru \url{https://www.linuxexpres.cz/praxe/sprava-linuxoveho-serveru}
		\end{itemize}
		\item LinuxDays (největší konference) \url{https://www.linuxdays.cz/}
		\item Seminář Install fest \url{https://installfest.cz/}
		\item Konference OpenAlt \url{https://openalt.cz/}
		\item OpenOffice/LibreOffice \url{https://www.openoffice.cz/}
		\begin{itemize}
			\item Podrobná příručka \url{https://www.knihaoffice.cz/}
			\item Fórum \url{https://forum.openoffice.cz/}
		\end{itemize}
		\item Ubuntu \url{https://www.ubuntu.cz/}
		\begin{itemize}
			\item Wiki \url{http://wiki.ubuntu.cz/}
			\item Fórum \url{http://forum.ubuntu.cz/}
			\item Kubuntu \url{http://www.kubuntu.cz/}
			\item Xubuntu \url{http://www.xubuntu.cz/}
			\item Lubuntu \url{http://www.lubuntu.cz/}
		\end{itemize}
		\item Fedora \url{https://mojefedora.cz/}
		\begin{itemize}
			\item Wiki \url{https://wiki.mojefedora.cz/doku.php}
			\item Fórum \url{https://forum.mojefedora.cz/}
			\item Příručka \url{https://wiki.mojefedora.cz/doku.php?id=navody:prirucka:obsah}
		\end{itemize}
		\item Linux Mint \url{https://www.linux-mint-czech.cz/}
		\begin{itemize}
			\item Fórum \url{https://forum.linux-mint-czech.cz/}
		\end{itemize}
	\end{itemize}
\end{frame}

\subsection{The very end}

\begin{frame}{The end}{Our course is over\ldots}
	\begin{center}
		\ldots I~hope it was helpful for You\ldots
		\vfill
		\ldots any feedback is welcomed\ldots
		\vfill
		\ldots happy Linux hacking\ldots
		\vfill
		\ldots any final questions?
		\vfill
	\end{center}
	\begin{flushright}
		\begin{tiny}
		\href{https://en.wikipedia.org/wiki/XeTeX}{Typesetting} using \XeLaTeX~on \href{https://www.opensuse.org/}{openSUSE} \href{https://en.wikipedia.org/wiki/GNU}{GNU}/\href{https://en.wikipedia.org/wiki/Linux}{Linux} \today
		\end{tiny}
	\end{flushright}
\end{frame}

\end{document}

% TODO Missing topics
% * Priority of MetaCentrum tasks - priority is calculated among user's tasks
% * qualter JOBID -p PRIORITY
% * qsub -p PRIORITY
% * PRIORITY <-1204,+1023> (default 0)
% * BASH arrays, https://opensource.com/article/18/5/you-dont-know-bash-intro-bash-arrays
